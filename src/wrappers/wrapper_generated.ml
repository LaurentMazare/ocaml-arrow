(* THIS FILE IS AUTOMATICALLY GENERATED, DO NOT EDIT! *)

open Ctypes
module C = Arrow_bindings.C (Arrow_generated)
type array_ = C.array_
type array_builder = C.array_builder
type binary_array = C.binary_array
type binary_array_builder = C.binary_array_builder
type binary_data_type = C.binary_data_type
type boolean_array = C.boolean_array
type boolean_array_builder = C.boolean_array_builder
type boolean_data_type = C.boolean_data_type
type buffer = C.buffer
type buffer_input_stream = C.buffer_input_stream
type buffer_output_stream = C.buffer_output_stream
type csv_read_options = C.csv_read_options
type csv_reader = C.csv_reader
type cast_options = C.cast_options
type chunked_array = C.chunked_array
type codec = C.codec
type column = C.column
type compressed_input_stream = C.compressed_input_stream
type compressed_output_stream = C.compressed_output_stream
type count_options = C.count_options
type data_type = C.data_type
type date32_array = C.date32_array
type date32_array_builder = C.date32_array_builder
type date32_data_type = C.date32_data_type
type date64_array = C.date64_array
type date64_array_builder = C.date64_array_builder
type date64_data_type = C.date64_data_type
type decimal128 = C.decimal128
type decimal128_array = C.decimal128_array
type decimal128_array_builder = C.decimal128_array_builder
type decimal128_data_type = C.decimal128_data_type
type decimal_data_type = C.decimal_data_type
type dense_union_array = C.dense_union_array
type dense_union_data_type = C.dense_union_data_type
type dictionary_array = C.dictionary_array
type dictionary_data_type = C.dictionary_data_type
type double_array = C.double_array
type double_array_builder = C.double_array_builder
type double_data_type = C.double_data_type
type feather_file_reader = C.feather_file_reader
type feather_file_writer = C.feather_file_writer
type field = C.field
type file_output_stream = C.file_output_stream
type fixed_size_binary_array = C.fixed_size_binary_array
type fixed_size_binary_data_type = C.fixed_size_binary_data_type
type fixed_width_data_type = C.fixed_width_data_type
type float_array = C.float_array
type float_array_builder = C.float_array_builder
type float_data_type = C.float_data_type
type floating_point_data_type = C.floating_point_data_type
type gio_input_stream = C.gio_input_stream
type gio_output_stream = C.gio_output_stream
type input_stream = C.input_stream
type int16_array = C.int16_array
type int16_array_builder = C.int16_array_builder
type int16_data_type = C.int16_data_type
type int32_array = C.int32_array
type int32_array_builder = C.int32_array_builder
type int32_data_type = C.int32_data_type
type int64_array = C.int64_array
type int64_array_builder = C.int64_array_builder
type int64_data_type = C.int64_data_type
type int8_array = C.int8_array
type int8_array_builder = C.int8_array_builder
type int8_data_type = C.int8_data_type
type int_array_builder = C.int_array_builder
type integer_data_type = C.integer_data_type
type list_array = C.list_array
type list_array_builder = C.list_array_builder
type list_data_type = C.list_data_type
type memory_mapped_input_stream = C.memory_mapped_input_stream
type mutable_buffer = C.mutable_buffer
type null_array = C.null_array
type null_array_builder = C.null_array_builder
type null_data_type = C.null_data_type
type numeric_array = C.numeric_array
type numeric_data_type = C.numeric_data_type
type output_stream = C.output_stream
type primitive_array = C.primitive_array
type record_batch = C.record_batch
type record_batch_builder = C.record_batch_builder
type record_batch_file_reader = C.record_batch_file_reader
type record_batch_file_writer = C.record_batch_file_writer
type record_batch_reader = C.record_batch_reader
type record_batch_stream_reader = C.record_batch_stream_reader
type record_batch_stream_writer = C.record_batch_stream_writer
type record_batch_writer = C.record_batch_writer
type resizable_buffer = C.resizable_buffer
type schema = C.schema
type seekable_input_stream = C.seekable_input_stream
type sparse_union_array = C.sparse_union_array
type sparse_union_data_type = C.sparse_union_data_type
type string_array = C.string_array
type string_array_builder = C.string_array_builder
type string_data_type = C.string_data_type
type struct_array = C.struct_array
type struct_array_builder = C.struct_array_builder
type struct_data_type = C.struct_data_type
type table = C.table
type table_batch_reader = C.table_batch_reader
type tensor = C.tensor
type time32_array = C.time32_array
type time32_array_builder = C.time32_array_builder
type time32_data_type = C.time32_data_type
type time64_array = C.time64_array
type time64_array_builder = C.time64_array_builder
type time64_data_type = C.time64_data_type
type time_data_type = C.time_data_type
type timestamp_array = C.timestamp_array
type timestamp_array_builder = C.timestamp_array_builder
type timestamp_data_type = C.timestamp_data_type
type u_int16_array = C.u_int16_array
type u_int16_array_builder = C.u_int16_array_builder
type u_int16_data_type = C.u_int16_data_type
type u_int32_array = C.u_int32_array
type u_int32_array_builder = C.u_int32_array_builder
type u_int32_data_type = C.u_int32_data_type
type u_int64_array = C.u_int64_array
type u_int64_array_builder = C.u_int64_array_builder
type u_int64_data_type = C.u_int64_data_type
type u_int8_array = C.u_int8_array
type u_int8_array_builder = C.u_int8_array_builder
type u_int8_data_type = C.u_int8_data_type
type u_int_array_builder = C.u_int_array_builder
type union_array = C.union_array
type union_data_type = C.union_data_type

module Array = struct
  type t = array_
  let cast t target_data_type options =
    let gerr__ = CArray.make (ptr C.GError.t) 1 in
    let res = C.Array.cast t target_data_type options (CArray.start gerr__) in
    let gerr__ = CArray.get gerr__ 0 in
    if not (Ctypes.is_null gerr__)
    then begin
      let msg = getf (!@ gerr__) C.GError.message |> C.strdup in
      C.GError.free gerr__;
      failwith msg
    end;
    res

  let count t options =
    let gerr__ = CArray.make (ptr C.GError.t) 1 in
    let res = C.Array.count t options (CArray.start gerr__) in
    let gerr__ = CArray.get gerr__ 0 in
    if not (Ctypes.is_null gerr__)
    then begin
      let msg = getf (!@ gerr__) C.GError.message |> C.strdup in
      C.GError.free gerr__;
      failwith msg
    end;
    res

  let count_values t =
    let gerr__ = CArray.make (ptr C.GError.t) 1 in
    let res = C.Array.count_values t (CArray.start gerr__) in
    let gerr__ = CArray.get gerr__ 0 in
    if not (Ctypes.is_null gerr__)
    then begin
      let msg = getf (!@ gerr__) C.GError.message |> C.strdup in
      C.GError.free gerr__;
      failwith msg
    end;
    res

  let dictionary_encode t =
    let gerr__ = CArray.make (ptr C.GError.t) 1 in
    let res = C.Array.dictionary_encode t (CArray.start gerr__) in
    let gerr__ = CArray.get gerr__ 0 in
    if not (Ctypes.is_null gerr__)
    then begin
      let msg = getf (!@ gerr__) C.GError.message |> C.strdup in
      C.GError.free gerr__;
      failwith msg
    end;
    res

  let equal t other_array =
    let res = C.Array.equal t other_array in
    res

  let equal_approx t other_array =
    let res = C.Array.equal_approx t other_array in
    res

  let equal_range t start_index other_array other_start_index end_index =
    let res = C.Array.equal_range t start_index other_array other_start_index end_index in
    res

  let get_length t =
    let res = C.Array.get_length t in
    res

  let get_n_nulls t =
    let res = C.Array.get_n_nulls t in
    res

  let get_null_bitmap t =
    let res = C.Array.get_null_bitmap t in
    res

  let get_offset t =
    let res = C.Array.get_offset t in
    res

  let get_value_data_type t =
    let res = C.Array.get_value_data_type t in
    res

  let is_null t i =
    let res = C.Array.is_null t i in
    res

  let is_valid t i =
    let res = C.Array.is_valid t i in
    res

  let slice t offset length =
    let res = C.Array.slice t offset length in
    res

  let to_string t =
    let gerr__ = CArray.make (ptr C.GError.t) 1 in
    let res = C.Array.to_string t (CArray.start gerr__) in
    let gerr__ = CArray.get gerr__ 0 in
    if not (Ctypes.is_null gerr__)
    then begin
      let msg = getf (!@ gerr__) C.GError.message |> C.strdup in
      C.GError.free gerr__;
      failwith msg
    end;
    res

  let unique t =
    let gerr__ = CArray.make (ptr C.GError.t) 1 in
    let res = C.Array.unique t (CArray.start gerr__) in
    let gerr__ = CArray.get gerr__ 0 in
    if not (Ctypes.is_null gerr__)
    then begin
      let msg = getf (!@ gerr__) C.GError.message |> C.strdup in
      C.GError.free gerr__;
      failwith msg
    end;
    res

end

module ArrayBuilder = struct
  type t = array_builder
  let finish t =
    let gerr__ = CArray.make (ptr C.GError.t) 1 in
    let res = C.ArrayBuilder.finish t (CArray.start gerr__) in
    let gerr__ = CArray.get gerr__ 0 in
    if not (Ctypes.is_null gerr__)
    then begin
      let msg = getf (!@ gerr__) C.GError.message |> C.strdup in
      C.GError.free gerr__;
      failwith msg
    end;
    res

  let get_value_data_type t =
    let res = C.ArrayBuilder.get_value_data_type t in
    res

end

module BinaryArray = struct
  type t = binary_array
  let new_ length value_offsets data null_bitmap n_nulls =
    let res = C.BinaryArray.new_ length value_offsets data null_bitmap n_nulls in
    res

  let get_buffer t =
    let res = C.BinaryArray.get_buffer t in
    res

  let get_offsets_buffer t =
    let res = C.BinaryArray.get_offsets_buffer t in
    res

end

module BinaryArrayBuilder = struct
  type t = binary_array_builder
  let new_ () =
    let res = C.BinaryArrayBuilder.new_ () in
    res

  let append_null t =
    let gerr__ = CArray.make (ptr C.GError.t) 1 in
    let res = C.BinaryArrayBuilder.append_null t (CArray.start gerr__) in
    let gerr__ = CArray.get gerr__ 0 in
    if not (Ctypes.is_null gerr__)
    then begin
      let msg = getf (!@ gerr__) C.GError.message |> C.strdup in
      C.GError.free gerr__;
      failwith msg
    end;
    res

end

module BinaryDataType = struct
  type t = binary_data_type
  let new_ () =
    let res = C.BinaryDataType.new_ () in
    res

end

module BooleanArray = struct
  type t = boolean_array
  let new_ length data null_bitmap n_nulls =
    let res = C.BooleanArray.new_ length data null_bitmap n_nulls in
    res

  let and_ t right =
    let gerr__ = CArray.make (ptr C.GError.t) 1 in
    let res = C.BooleanArray.and_ t right (CArray.start gerr__) in
    let gerr__ = CArray.get gerr__ 0 in
    if not (Ctypes.is_null gerr__)
    then begin
      let msg = getf (!@ gerr__) C.GError.message |> C.strdup in
      C.GError.free gerr__;
      failwith msg
    end;
    res

  let get_value t i =
    let res = C.BooleanArray.get_value t i in
    res

  let invert t =
    let gerr__ = CArray.make (ptr C.GError.t) 1 in
    let res = C.BooleanArray.invert t (CArray.start gerr__) in
    let gerr__ = CArray.get gerr__ 0 in
    if not (Ctypes.is_null gerr__)
    then begin
      let msg = getf (!@ gerr__) C.GError.message |> C.strdup in
      C.GError.free gerr__;
      failwith msg
    end;
    res

  let or_ t right =
    let gerr__ = CArray.make (ptr C.GError.t) 1 in
    let res = C.BooleanArray.or_ t right (CArray.start gerr__) in
    let gerr__ = CArray.get gerr__ 0 in
    if not (Ctypes.is_null gerr__)
    then begin
      let msg = getf (!@ gerr__) C.GError.message |> C.strdup in
      C.GError.free gerr__;
      failwith msg
    end;
    res

  let xor t right =
    let gerr__ = CArray.make (ptr C.GError.t) 1 in
    let res = C.BooleanArray.xor t right (CArray.start gerr__) in
    let gerr__ = CArray.get gerr__ 0 in
    if not (Ctypes.is_null gerr__)
    then begin
      let msg = getf (!@ gerr__) C.GError.message |> C.strdup in
      C.GError.free gerr__;
      failwith msg
    end;
    res

end

module BooleanArrayBuilder = struct
  type t = boolean_array_builder
  let new_ () =
    let res = C.BooleanArrayBuilder.new_ () in
    res

  let append_null t =
    let gerr__ = CArray.make (ptr C.GError.t) 1 in
    let res = C.BooleanArrayBuilder.append_null t (CArray.start gerr__) in
    let gerr__ = CArray.get gerr__ 0 in
    if not (Ctypes.is_null gerr__)
    then begin
      let msg = getf (!@ gerr__) C.GError.message |> C.strdup in
      C.GError.free gerr__;
      failwith msg
    end;
    res

  let append_nulls t n =
    let gerr__ = CArray.make (ptr C.GError.t) 1 in
    let res = C.BooleanArrayBuilder.append_nulls t n (CArray.start gerr__) in
    let gerr__ = CArray.get gerr__ 0 in
    if not (Ctypes.is_null gerr__)
    then begin
      let msg = getf (!@ gerr__) C.GError.message |> C.strdup in
      C.GError.free gerr__;
      failwith msg
    end;
    res

  let append_value t value =
    let gerr__ = CArray.make (ptr C.GError.t) 1 in
    let res = C.BooleanArrayBuilder.append_value t value (CArray.start gerr__) in
    let gerr__ = CArray.get gerr__ 0 in
    if not (Ctypes.is_null gerr__)
    then begin
      let msg = getf (!@ gerr__) C.GError.message |> C.strdup in
      C.GError.free gerr__;
      failwith msg
    end;
    res

end

module BooleanDataType = struct
  type t = boolean_data_type
  let new_ () =
    let res = C.BooleanDataType.new_ () in
    res

end

module Buffer = struct
  type t = buffer
  let copy t start size =
    let gerr__ = CArray.make (ptr C.GError.t) 1 in
    let res = C.Buffer.copy t start size (CArray.start gerr__) in
    let gerr__ = CArray.get gerr__ 0 in
    if not (Ctypes.is_null gerr__)
    then begin
      let msg = getf (!@ gerr__) C.GError.message |> C.strdup in
      C.GError.free gerr__;
      failwith msg
    end;
    res

  let equal t other_buffer =
    let res = C.Buffer.equal t other_buffer in
    res

  let equal_n_bytes t other_buffer n_bytes =
    let res = C.Buffer.equal_n_bytes t other_buffer n_bytes in
    res

  let get_capacity t =
    let res = C.Buffer.get_capacity t in
    res

  let get_parent t =
    let res = C.Buffer.get_parent t in
    res

  let get_size t =
    let res = C.Buffer.get_size t in
    res

  let is_mutable t =
    let res = C.Buffer.is_mutable t in
    res

  let slice t offset size =
    let res = C.Buffer.slice t offset size in
    res

end

module BufferInputStream = struct
  type t = buffer_input_stream
  let new_ buffer =
    let res = C.BufferInputStream.new_ buffer in
    res

  let get_buffer t =
    let res = C.BufferInputStream.get_buffer t in
    res

end

module BufferOutputStream = struct
  type t = buffer_output_stream
  let new_ buffer =
    let res = C.BufferOutputStream.new_ buffer in
    res

end

module CSVReadOptions = struct
  type t = csv_read_options
  let new_ () =
    let res = C.CSVReadOptions.new_ () in
    res

end

module CSVReader = struct
  type t = csv_reader
  let new_ input options =
    let gerr__ = CArray.make (ptr C.GError.t) 1 in
    let res = C.CSVReader.new_ input options (CArray.start gerr__) in
    let gerr__ = CArray.get gerr__ 0 in
    if not (Ctypes.is_null gerr__)
    then begin
      let msg = getf (!@ gerr__) C.GError.message |> C.strdup in
      C.GError.free gerr__;
      failwith msg
    end;
    res

  let read t =
    let gerr__ = CArray.make (ptr C.GError.t) 1 in
    let res = C.CSVReader.read t (CArray.start gerr__) in
    let gerr__ = CArray.get gerr__ 0 in
    if not (Ctypes.is_null gerr__)
    then begin
      let msg = getf (!@ gerr__) C.GError.message |> C.strdup in
      C.GError.free gerr__;
      failwith msg
    end;
    res

end

module CastOptions = struct
  type t = cast_options
  let new_ () =
    let res = C.CastOptions.new_ () in
    res

end

module ChunkedArray = struct
  type t = chunked_array
  let equal t other_chunked_array =
    let res = C.ChunkedArray.equal t other_chunked_array in
    res

  let get_value_data_type t =
    let res = C.ChunkedArray.get_value_data_type t in
    res

  let to_string t =
    let gerr__ = CArray.make (ptr C.GError.t) 1 in
    let res = C.ChunkedArray.to_string t (CArray.start gerr__) in
    let gerr__ = CArray.get gerr__ 0 in
    if not (Ctypes.is_null gerr__)
    then begin
      let msg = getf (!@ gerr__) C.GError.message |> C.strdup in
      C.GError.free gerr__;
      failwith msg
    end;
    res

end

module Codec = struct
  type t = codec
  let get_name t =
    let res = C.Codec.get_name t in
    res

end

module Column = struct
  type t = column
  let new_array field array =
    let res = C.Column.new_array field array in
    res

  let new_chunked_array field chunked_array =
    let res = C.Column.new_chunked_array field chunked_array in
    res

  let equal t other_column =
    let res = C.Column.equal t other_column in
    res

  let get_data t =
    let res = C.Column.get_data t in
    res

  let get_data_type t =
    let res = C.Column.get_data_type t in
    res

  let get_field t =
    let res = C.Column.get_field t in
    res

  let get_name t =
    let res = C.Column.get_name t in
    res

  let to_string t =
    let gerr__ = CArray.make (ptr C.GError.t) 1 in
    let res = C.Column.to_string t (CArray.start gerr__) in
    let gerr__ = CArray.get gerr__ 0 in
    if not (Ctypes.is_null gerr__)
    then begin
      let msg = getf (!@ gerr__) C.GError.message |> C.strdup in
      C.GError.free gerr__;
      failwith msg
    end;
    res

end

module CompressedInputStream = struct
  type t = compressed_input_stream
  let new_ codec raw =
    let gerr__ = CArray.make (ptr C.GError.t) 1 in
    let res = C.CompressedInputStream.new_ codec raw (CArray.start gerr__) in
    let gerr__ = CArray.get gerr__ 0 in
    if not (Ctypes.is_null gerr__)
    then begin
      let msg = getf (!@ gerr__) C.GError.message |> C.strdup in
      C.GError.free gerr__;
      failwith msg
    end;
    res

end

module CompressedOutputStream = struct
  type t = compressed_output_stream
  let new_ codec raw =
    let gerr__ = CArray.make (ptr C.GError.t) 1 in
    let res = C.CompressedOutputStream.new_ codec raw (CArray.start gerr__) in
    let gerr__ = CArray.get gerr__ 0 in
    if not (Ctypes.is_null gerr__)
    then begin
      let msg = getf (!@ gerr__) C.GError.message |> C.strdup in
      C.GError.free gerr__;
      failwith msg
    end;
    res

end

module CountOptions = struct
  type t = count_options
  let new_ () =
    let res = C.CountOptions.new_ () in
    res

end

module DataType = struct
  type t = data_type
  let equal t other_data_type =
    let res = C.DataType.equal t other_data_type in
    res

  let to_string t =
    let res = C.DataType.to_string t in
    res

end

module Date32Array = struct
  type t = date32_array
  let new_ length data null_bitmap n_nulls =
    let res = C.Date32Array.new_ length data null_bitmap n_nulls in
    res

end

module Date32ArrayBuilder = struct
  type t = date32_array_builder
  let new_ () =
    let res = C.Date32ArrayBuilder.new_ () in
    res

  let append_null t =
    let gerr__ = CArray.make (ptr C.GError.t) 1 in
    let res = C.Date32ArrayBuilder.append_null t (CArray.start gerr__) in
    let gerr__ = CArray.get gerr__ 0 in
    if not (Ctypes.is_null gerr__)
    then begin
      let msg = getf (!@ gerr__) C.GError.message |> C.strdup in
      C.GError.free gerr__;
      failwith msg
    end;
    res

  let append_nulls t n =
    let gerr__ = CArray.make (ptr C.GError.t) 1 in
    let res = C.Date32ArrayBuilder.append_nulls t n (CArray.start gerr__) in
    let gerr__ = CArray.get gerr__ 0 in
    if not (Ctypes.is_null gerr__)
    then begin
      let msg = getf (!@ gerr__) C.GError.message |> C.strdup in
      C.GError.free gerr__;
      failwith msg
    end;
    res

end

module Date32DataType = struct
  type t = date32_data_type
  let new_ () =
    let res = C.Date32DataType.new_ () in
    res

end

module Date64Array = struct
  type t = date64_array
  let new_ length data null_bitmap n_nulls =
    let res = C.Date64Array.new_ length data null_bitmap n_nulls in
    res

  let get_value t i =
    let res = C.Date64Array.get_value t i in
    res

end

module Date64ArrayBuilder = struct
  type t = date64_array_builder
  let new_ () =
    let res = C.Date64ArrayBuilder.new_ () in
    res

  let append_null t =
    let gerr__ = CArray.make (ptr C.GError.t) 1 in
    let res = C.Date64ArrayBuilder.append_null t (CArray.start gerr__) in
    let gerr__ = CArray.get gerr__ 0 in
    if not (Ctypes.is_null gerr__)
    then begin
      let msg = getf (!@ gerr__) C.GError.message |> C.strdup in
      C.GError.free gerr__;
      failwith msg
    end;
    res

  let append_nulls t n =
    let gerr__ = CArray.make (ptr C.GError.t) 1 in
    let res = C.Date64ArrayBuilder.append_nulls t n (CArray.start gerr__) in
    let gerr__ = CArray.get gerr__ 0 in
    if not (Ctypes.is_null gerr__)
    then begin
      let msg = getf (!@ gerr__) C.GError.message |> C.strdup in
      C.GError.free gerr__;
      failwith msg
    end;
    res

  let append_value t value =
    let gerr__ = CArray.make (ptr C.GError.t) 1 in
    let res = C.Date64ArrayBuilder.append_value t value (CArray.start gerr__) in
    let gerr__ = CArray.get gerr__ 0 in
    if not (Ctypes.is_null gerr__)
    then begin
      let msg = getf (!@ gerr__) C.GError.message |> C.strdup in
      C.GError.free gerr__;
      failwith msg
    end;
    res

end

module Date64DataType = struct
  type t = date64_data_type
  let new_ () =
    let res = C.Date64DataType.new_ () in
    res

end

module Decimal128 = struct
  type t = decimal128
  let new_integer data =
    let res = C.Decimal128.new_integer data in
    res

  let new_string data =
    let res = C.Decimal128.new_string data in
    res

  let divide t right remainder =
    let gerr__ = CArray.make (ptr C.GError.t) 1 in
    let res = C.Decimal128.divide t right remainder (CArray.start gerr__) in
    let gerr__ = CArray.get gerr__ 0 in
    if not (Ctypes.is_null gerr__)
    then begin
      let msg = getf (!@ gerr__) C.GError.message |> C.strdup in
      C.GError.free gerr__;
      failwith msg
    end;
    res

  let equal t other_decimal =
    let res = C.Decimal128.equal t other_decimal in
    res

  let greater_than t other_decimal =
    let res = C.Decimal128.greater_than t other_decimal in
    res

  let greater_than_or_equal t other_decimal =
    let res = C.Decimal128.greater_than_or_equal t other_decimal in
    res

  let less_than t other_decimal =
    let res = C.Decimal128.less_than t other_decimal in
    res

  let less_than_or_equal t other_decimal =
    let res = C.Decimal128.less_than_or_equal t other_decimal in
    res

  let minus t right =
    let res = C.Decimal128.minus t right in
    res

  let multiply t right =
    let res = C.Decimal128.multiply t right in
    res

  let not_equal t other_decimal =
    let res = C.Decimal128.not_equal t other_decimal in
    res

  let plus t right =
    let res = C.Decimal128.plus t right in
    res

  let to_integer t =
    let res = C.Decimal128.to_integer t in
    res

  let to_string t =
    let res = C.Decimal128.to_string t in
    res

end

module Decimal128Array = struct
  type t = decimal128_array
  let format_value t i =
    let res = C.Decimal128Array.format_value t i in
    res

  let get_value t i =
    let res = C.Decimal128Array.get_value t i in
    res

end

module Decimal128ArrayBuilder = struct
  type t = decimal128_array_builder
  let new_ data_type =
    let res = C.Decimal128ArrayBuilder.new_ data_type in
    res

  let append_null t =
    let gerr__ = CArray.make (ptr C.GError.t) 1 in
    let res = C.Decimal128ArrayBuilder.append_null t (CArray.start gerr__) in
    let gerr__ = CArray.get gerr__ 0 in
    if not (Ctypes.is_null gerr__)
    then begin
      let msg = getf (!@ gerr__) C.GError.message |> C.strdup in
      C.GError.free gerr__;
      failwith msg
    end;
    res

  let append_value t value =
    let gerr__ = CArray.make (ptr C.GError.t) 1 in
    let res = C.Decimal128ArrayBuilder.append_value t value (CArray.start gerr__) in
    let gerr__ = CArray.get gerr__ 0 in
    if not (Ctypes.is_null gerr__)
    then begin
      let msg = getf (!@ gerr__) C.GError.message |> C.strdup in
      C.GError.free gerr__;
      failwith msg
    end;
    res

end

module Decimal128DataType = struct
  type t = decimal128_data_type
end

module DecimalDataType = struct
  type t = decimal_data_type
end

module DenseUnionArray = struct
  type t = dense_union_array
end

module DenseUnionDataType = struct
  type t = dense_union_data_type
end

module DictionaryArray = struct
  type t = dictionary_array
  let new_ data_type indices =
    let res = C.DictionaryArray.new_ data_type indices in
    res

  let get_dictionary t =
    let res = C.DictionaryArray.get_dictionary t in
    res

  let get_dictionary_data_type t =
    let res = C.DictionaryArray.get_dictionary_data_type t in
    res

  let get_indices t =
    let res = C.DictionaryArray.get_indices t in
    res

end

module DictionaryDataType = struct
  type t = dictionary_data_type
  let new_ index_data_type dictionary ordered =
    let res = C.DictionaryDataType.new_ index_data_type dictionary ordered in
    res

  let get_dictionary t =
    let res = C.DictionaryDataType.get_dictionary t in
    res

  let get_index_data_type t =
    let res = C.DictionaryDataType.get_index_data_type t in
    res

  let is_ordered t =
    let res = C.DictionaryDataType.is_ordered t in
    res

end

module DoubleArray = struct
  type t = double_array
  let new_ length data null_bitmap n_nulls =
    let res = C.DoubleArray.new_ length data null_bitmap n_nulls in
    res

  let get_value t i =
    let res = C.DoubleArray.get_value t i in
    res

  let sum t =
    let gerr__ = CArray.make (ptr C.GError.t) 1 in
    let res = C.DoubleArray.sum t (CArray.start gerr__) in
    let gerr__ = CArray.get gerr__ 0 in
    if not (Ctypes.is_null gerr__)
    then begin
      let msg = getf (!@ gerr__) C.GError.message |> C.strdup in
      C.GError.free gerr__;
      failwith msg
    end;
    res

end

module DoubleArrayBuilder = struct
  type t = double_array_builder
  let new_ () =
    let res = C.DoubleArrayBuilder.new_ () in
    res

  let append_null t =
    let gerr__ = CArray.make (ptr C.GError.t) 1 in
    let res = C.DoubleArrayBuilder.append_null t (CArray.start gerr__) in
    let gerr__ = CArray.get gerr__ 0 in
    if not (Ctypes.is_null gerr__)
    then begin
      let msg = getf (!@ gerr__) C.GError.message |> C.strdup in
      C.GError.free gerr__;
      failwith msg
    end;
    res

  let append_nulls t n =
    let gerr__ = CArray.make (ptr C.GError.t) 1 in
    let res = C.DoubleArrayBuilder.append_nulls t n (CArray.start gerr__) in
    let gerr__ = CArray.get gerr__ 0 in
    if not (Ctypes.is_null gerr__)
    then begin
      let msg = getf (!@ gerr__) C.GError.message |> C.strdup in
      C.GError.free gerr__;
      failwith msg
    end;
    res

  let append_value t value =
    let gerr__ = CArray.make (ptr C.GError.t) 1 in
    let res = C.DoubleArrayBuilder.append_value t value (CArray.start gerr__) in
    let gerr__ = CArray.get gerr__ 0 in
    if not (Ctypes.is_null gerr__)
    then begin
      let msg = getf (!@ gerr__) C.GError.message |> C.strdup in
      C.GError.free gerr__;
      failwith msg
    end;
    res

end

module DoubleDataType = struct
  type t = double_data_type
  let new_ () =
    let res = C.DoubleDataType.new_ () in
    res

end

module FeatherFileReader = struct
  type t = feather_file_reader
  let new_ file =
    let gerr__ = CArray.make (ptr C.GError.t) 1 in
    let res = C.FeatherFileReader.new_ file (CArray.start gerr__) in
    let gerr__ = CArray.get gerr__ 0 in
    if not (Ctypes.is_null gerr__)
    then begin
      let msg = getf (!@ gerr__) C.GError.message |> C.strdup in
      C.GError.free gerr__;
      failwith msg
    end;
    res

  let get_description t =
    let res = C.FeatherFileReader.get_description t in
    res

  let get_n_columns t =
    let res = C.FeatherFileReader.get_n_columns t in
    res

  let get_n_rows t =
    let res = C.FeatherFileReader.get_n_rows t in
    res

  let has_description t =
    let res = C.FeatherFileReader.has_description t in
    res

  let read t =
    let gerr__ = CArray.make (ptr C.GError.t) 1 in
    let res = C.FeatherFileReader.read t (CArray.start gerr__) in
    let gerr__ = CArray.get gerr__ 0 in
    if not (Ctypes.is_null gerr__)
    then begin
      let msg = getf (!@ gerr__) C.GError.message |> C.strdup in
      C.GError.free gerr__;
      failwith msg
    end;
    res

end

module FeatherFileWriter = struct
  type t = feather_file_writer
  let new_ sink =
    let gerr__ = CArray.make (ptr C.GError.t) 1 in
    let res = C.FeatherFileWriter.new_ sink (CArray.start gerr__) in
    let gerr__ = CArray.get gerr__ 0 in
    if not (Ctypes.is_null gerr__)
    then begin
      let msg = getf (!@ gerr__) C.GError.message |> C.strdup in
      C.GError.free gerr__;
      failwith msg
    end;
    res

  let append t name array =
    let gerr__ = CArray.make (ptr C.GError.t) 1 in
    let res = C.FeatherFileWriter.append t name array (CArray.start gerr__) in
    let gerr__ = CArray.get gerr__ 0 in
    if not (Ctypes.is_null gerr__)
    then begin
      let msg = getf (!@ gerr__) C.GError.message |> C.strdup in
      C.GError.free gerr__;
      failwith msg
    end;
    res

  let close t =
    let gerr__ = CArray.make (ptr C.GError.t) 1 in
    let res = C.FeatherFileWriter.close t (CArray.start gerr__) in
    let gerr__ = CArray.get gerr__ 0 in
    if not (Ctypes.is_null gerr__)
    then begin
      let msg = getf (!@ gerr__) C.GError.message |> C.strdup in
      C.GError.free gerr__;
      failwith msg
    end;
    res

  let write t table =
    let gerr__ = CArray.make (ptr C.GError.t) 1 in
    let res = C.FeatherFileWriter.write t table (CArray.start gerr__) in
    let gerr__ = CArray.get gerr__ 0 in
    if not (Ctypes.is_null gerr__)
    then begin
      let msg = getf (!@ gerr__) C.GError.message |> C.strdup in
      C.GError.free gerr__;
      failwith msg
    end;
    res

end

module Field = struct
  type t = field
  let new_ name data_type =
    let res = C.Field.new_ name data_type in
    res

  let new_full name data_type nullable =
    let res = C.Field.new_full name data_type nullable in
    res

  let equal t other_field =
    let res = C.Field.equal t other_field in
    res

  let get_data_type t =
    let res = C.Field.get_data_type t in
    res

  let get_name t =
    let res = C.Field.get_name t in
    res

  let is_nullable t =
    let res = C.Field.is_nullable t in
    res

  let to_string t =
    let res = C.Field.to_string t in
    res

end

module FileOutputStream = struct
  type t = file_output_stream
  let new_ path append =
    let gerr__ = CArray.make (ptr C.GError.t) 1 in
    let res = C.FileOutputStream.new_ path append (CArray.start gerr__) in
    let gerr__ = CArray.get gerr__ 0 in
    if not (Ctypes.is_null gerr__)
    then begin
      let msg = getf (!@ gerr__) C.GError.message |> C.strdup in
      C.GError.free gerr__;
      failwith msg
    end;
    res

end

module FixedSizeBinaryArray = struct
  type t = fixed_size_binary_array
end

module FixedSizeBinaryDataType = struct
  type t = fixed_size_binary_data_type
end

module FixedWidthDataType = struct
  type t = fixed_width_data_type
end

module FloatArray = struct
  type t = float_array
  let new_ length data null_bitmap n_nulls =
    let res = C.FloatArray.new_ length data null_bitmap n_nulls in
    res

  let get_value t i =
    let res = C.FloatArray.get_value t i in
    res

  let sum t =
    let gerr__ = CArray.make (ptr C.GError.t) 1 in
    let res = C.FloatArray.sum t (CArray.start gerr__) in
    let gerr__ = CArray.get gerr__ 0 in
    if not (Ctypes.is_null gerr__)
    then begin
      let msg = getf (!@ gerr__) C.GError.message |> C.strdup in
      C.GError.free gerr__;
      failwith msg
    end;
    res

end

module FloatArrayBuilder = struct
  type t = float_array_builder
  let new_ () =
    let res = C.FloatArrayBuilder.new_ () in
    res

  let append_null t =
    let gerr__ = CArray.make (ptr C.GError.t) 1 in
    let res = C.FloatArrayBuilder.append_null t (CArray.start gerr__) in
    let gerr__ = CArray.get gerr__ 0 in
    if not (Ctypes.is_null gerr__)
    then begin
      let msg = getf (!@ gerr__) C.GError.message |> C.strdup in
      C.GError.free gerr__;
      failwith msg
    end;
    res

  let append_nulls t n =
    let gerr__ = CArray.make (ptr C.GError.t) 1 in
    let res = C.FloatArrayBuilder.append_nulls t n (CArray.start gerr__) in
    let gerr__ = CArray.get gerr__ 0 in
    if not (Ctypes.is_null gerr__)
    then begin
      let msg = getf (!@ gerr__) C.GError.message |> C.strdup in
      C.GError.free gerr__;
      failwith msg
    end;
    res

  let append_value t value =
    let gerr__ = CArray.make (ptr C.GError.t) 1 in
    let res = C.FloatArrayBuilder.append_value t value (CArray.start gerr__) in
    let gerr__ = CArray.get gerr__ 0 in
    if not (Ctypes.is_null gerr__)
    then begin
      let msg = getf (!@ gerr__) C.GError.message |> C.strdup in
      C.GError.free gerr__;
      failwith msg
    end;
    res

end

module FloatDataType = struct
  type t = float_data_type
  let new_ () =
    let res = C.FloatDataType.new_ () in
    res

end

module FloatingPointDataType = struct
  type t = floating_point_data_type
end

module GIOInputStream = struct
  type t = gio_input_stream
  let new_ gio_input_stream =
    let res = C.GIOInputStream.new_ gio_input_stream in
    res

end

module GIOOutputStream = struct
  type t = gio_output_stream
  let new_ gio_output_stream =
    let res = C.GIOOutputStream.new_ gio_output_stream in
    res

end

module InputStream = struct
  type t = input_stream
  let advance t n_bytes =
    let gerr__ = CArray.make (ptr C.GError.t) 1 in
    let res = C.InputStream.advance t n_bytes (CArray.start gerr__) in
    let gerr__ = CArray.get gerr__ 0 in
    if not (Ctypes.is_null gerr__)
    then begin
      let msg = getf (!@ gerr__) C.GError.message |> C.strdup in
      C.GError.free gerr__;
      failwith msg
    end;
    res

  let read_tensor t =
    let gerr__ = CArray.make (ptr C.GError.t) 1 in
    let res = C.InputStream.read_tensor t (CArray.start gerr__) in
    let gerr__ = CArray.get gerr__ 0 in
    if not (Ctypes.is_null gerr__)
    then begin
      let msg = getf (!@ gerr__) C.GError.message |> C.strdup in
      C.GError.free gerr__;
      failwith msg
    end;
    res

end

module Int16Array = struct
  type t = int16_array
  let new_ length data null_bitmap n_nulls =
    let res = C.Int16Array.new_ length data null_bitmap n_nulls in
    res

  let sum t =
    let gerr__ = CArray.make (ptr C.GError.t) 1 in
    let res = C.Int16Array.sum t (CArray.start gerr__) in
    let gerr__ = CArray.get gerr__ 0 in
    if not (Ctypes.is_null gerr__)
    then begin
      let msg = getf (!@ gerr__) C.GError.message |> C.strdup in
      C.GError.free gerr__;
      failwith msg
    end;
    res

end

module Int16ArrayBuilder = struct
  type t = int16_array_builder
  let new_ () =
    let res = C.Int16ArrayBuilder.new_ () in
    res

  let append_null t =
    let gerr__ = CArray.make (ptr C.GError.t) 1 in
    let res = C.Int16ArrayBuilder.append_null t (CArray.start gerr__) in
    let gerr__ = CArray.get gerr__ 0 in
    if not (Ctypes.is_null gerr__)
    then begin
      let msg = getf (!@ gerr__) C.GError.message |> C.strdup in
      C.GError.free gerr__;
      failwith msg
    end;
    res

  let append_nulls t n =
    let gerr__ = CArray.make (ptr C.GError.t) 1 in
    let res = C.Int16ArrayBuilder.append_nulls t n (CArray.start gerr__) in
    let gerr__ = CArray.get gerr__ 0 in
    if not (Ctypes.is_null gerr__)
    then begin
      let msg = getf (!@ gerr__) C.GError.message |> C.strdup in
      C.GError.free gerr__;
      failwith msg
    end;
    res

end

module Int16DataType = struct
  type t = int16_data_type
  let new_ () =
    let res = C.Int16DataType.new_ () in
    res

end

module Int32Array = struct
  type t = int32_array
  let new_ length data null_bitmap n_nulls =
    let res = C.Int32Array.new_ length data null_bitmap n_nulls in
    res

  let sum t =
    let gerr__ = CArray.make (ptr C.GError.t) 1 in
    let res = C.Int32Array.sum t (CArray.start gerr__) in
    let gerr__ = CArray.get gerr__ 0 in
    if not (Ctypes.is_null gerr__)
    then begin
      let msg = getf (!@ gerr__) C.GError.message |> C.strdup in
      C.GError.free gerr__;
      failwith msg
    end;
    res

end

module Int32ArrayBuilder = struct
  type t = int32_array_builder
  let new_ () =
    let res = C.Int32ArrayBuilder.new_ () in
    res

  let append_null t =
    let gerr__ = CArray.make (ptr C.GError.t) 1 in
    let res = C.Int32ArrayBuilder.append_null t (CArray.start gerr__) in
    let gerr__ = CArray.get gerr__ 0 in
    if not (Ctypes.is_null gerr__)
    then begin
      let msg = getf (!@ gerr__) C.GError.message |> C.strdup in
      C.GError.free gerr__;
      failwith msg
    end;
    res

  let append_nulls t n =
    let gerr__ = CArray.make (ptr C.GError.t) 1 in
    let res = C.Int32ArrayBuilder.append_nulls t n (CArray.start gerr__) in
    let gerr__ = CArray.get gerr__ 0 in
    if not (Ctypes.is_null gerr__)
    then begin
      let msg = getf (!@ gerr__) C.GError.message |> C.strdup in
      C.GError.free gerr__;
      failwith msg
    end;
    res

end

module Int32DataType = struct
  type t = int32_data_type
  let new_ () =
    let res = C.Int32DataType.new_ () in
    res

end

module Int64Array = struct
  type t = int64_array
  let new_ length data null_bitmap n_nulls =
    let res = C.Int64Array.new_ length data null_bitmap n_nulls in
    res

  let get_value t i =
    let res = C.Int64Array.get_value t i in
    res

  let sum t =
    let gerr__ = CArray.make (ptr C.GError.t) 1 in
    let res = C.Int64Array.sum t (CArray.start gerr__) in
    let gerr__ = CArray.get gerr__ 0 in
    if not (Ctypes.is_null gerr__)
    then begin
      let msg = getf (!@ gerr__) C.GError.message |> C.strdup in
      C.GError.free gerr__;
      failwith msg
    end;
    res

end

module Int64ArrayBuilder = struct
  type t = int64_array_builder
  let new_ () =
    let res = C.Int64ArrayBuilder.new_ () in
    res

  let append_null t =
    let gerr__ = CArray.make (ptr C.GError.t) 1 in
    let res = C.Int64ArrayBuilder.append_null t (CArray.start gerr__) in
    let gerr__ = CArray.get gerr__ 0 in
    if not (Ctypes.is_null gerr__)
    then begin
      let msg = getf (!@ gerr__) C.GError.message |> C.strdup in
      C.GError.free gerr__;
      failwith msg
    end;
    res

  let append_nulls t n =
    let gerr__ = CArray.make (ptr C.GError.t) 1 in
    let res = C.Int64ArrayBuilder.append_nulls t n (CArray.start gerr__) in
    let gerr__ = CArray.get gerr__ 0 in
    if not (Ctypes.is_null gerr__)
    then begin
      let msg = getf (!@ gerr__) C.GError.message |> C.strdup in
      C.GError.free gerr__;
      failwith msg
    end;
    res

  let append_value t value =
    let gerr__ = CArray.make (ptr C.GError.t) 1 in
    let res = C.Int64ArrayBuilder.append_value t value (CArray.start gerr__) in
    let gerr__ = CArray.get gerr__ 0 in
    if not (Ctypes.is_null gerr__)
    then begin
      let msg = getf (!@ gerr__) C.GError.message |> C.strdup in
      C.GError.free gerr__;
      failwith msg
    end;
    res

end

module Int64DataType = struct
  type t = int64_data_type
  let new_ () =
    let res = C.Int64DataType.new_ () in
    res

end

module Int8Array = struct
  type t = int8_array
  let new_ length data null_bitmap n_nulls =
    let res = C.Int8Array.new_ length data null_bitmap n_nulls in
    res

  let sum t =
    let gerr__ = CArray.make (ptr C.GError.t) 1 in
    let res = C.Int8Array.sum t (CArray.start gerr__) in
    let gerr__ = CArray.get gerr__ 0 in
    if not (Ctypes.is_null gerr__)
    then begin
      let msg = getf (!@ gerr__) C.GError.message |> C.strdup in
      C.GError.free gerr__;
      failwith msg
    end;
    res

end

module Int8ArrayBuilder = struct
  type t = int8_array_builder
  let new_ () =
    let res = C.Int8ArrayBuilder.new_ () in
    res

  let append_null t =
    let gerr__ = CArray.make (ptr C.GError.t) 1 in
    let res = C.Int8ArrayBuilder.append_null t (CArray.start gerr__) in
    let gerr__ = CArray.get gerr__ 0 in
    if not (Ctypes.is_null gerr__)
    then begin
      let msg = getf (!@ gerr__) C.GError.message |> C.strdup in
      C.GError.free gerr__;
      failwith msg
    end;
    res

  let append_nulls t n =
    let gerr__ = CArray.make (ptr C.GError.t) 1 in
    let res = C.Int8ArrayBuilder.append_nulls t n (CArray.start gerr__) in
    let gerr__ = CArray.get gerr__ 0 in
    if not (Ctypes.is_null gerr__)
    then begin
      let msg = getf (!@ gerr__) C.GError.message |> C.strdup in
      C.GError.free gerr__;
      failwith msg
    end;
    res

end

module Int8DataType = struct
  type t = int8_data_type
  let new_ () =
    let res = C.Int8DataType.new_ () in
    res

end

module IntArrayBuilder = struct
  type t = int_array_builder
  let new_ () =
    let res = C.IntArrayBuilder.new_ () in
    res

  let append_null t =
    let gerr__ = CArray.make (ptr C.GError.t) 1 in
    let res = C.IntArrayBuilder.append_null t (CArray.start gerr__) in
    let gerr__ = CArray.get gerr__ 0 in
    if not (Ctypes.is_null gerr__)
    then begin
      let msg = getf (!@ gerr__) C.GError.message |> C.strdup in
      C.GError.free gerr__;
      failwith msg
    end;
    res

  let append_nulls t n =
    let gerr__ = CArray.make (ptr C.GError.t) 1 in
    let res = C.IntArrayBuilder.append_nulls t n (CArray.start gerr__) in
    let gerr__ = CArray.get gerr__ 0 in
    if not (Ctypes.is_null gerr__)
    then begin
      let msg = getf (!@ gerr__) C.GError.message |> C.strdup in
      C.GError.free gerr__;
      failwith msg
    end;
    res

  let append_value t value =
    let gerr__ = CArray.make (ptr C.GError.t) 1 in
    let res = C.IntArrayBuilder.append_value t value (CArray.start gerr__) in
    let gerr__ = CArray.get gerr__ 0 in
    if not (Ctypes.is_null gerr__)
    then begin
      let msg = getf (!@ gerr__) C.GError.message |> C.strdup in
      C.GError.free gerr__;
      failwith msg
    end;
    res

end

module IntegerDataType = struct
  type t = integer_data_type
end

module ListArray = struct
  type t = list_array
  let new_ data_type length value_offsets values null_bitmap n_nulls =
    let res = C.ListArray.new_ data_type length value_offsets values null_bitmap n_nulls in
    res

  let get_value t i =
    let res = C.ListArray.get_value t i in
    res

  let get_value_type t =
    let res = C.ListArray.get_value_type t in
    res

end

module ListArrayBuilder = struct
  type t = list_array_builder
  let new_ data_type =
    let gerr__ = CArray.make (ptr C.GError.t) 1 in
    let res = C.ListArrayBuilder.new_ data_type (CArray.start gerr__) in
    let gerr__ = CArray.get gerr__ 0 in
    if not (Ctypes.is_null gerr__)
    then begin
      let msg = getf (!@ gerr__) C.GError.message |> C.strdup in
      C.GError.free gerr__;
      failwith msg
    end;
    res

  let append_null t =
    let gerr__ = CArray.make (ptr C.GError.t) 1 in
    let res = C.ListArrayBuilder.append_null t (CArray.start gerr__) in
    let gerr__ = CArray.get gerr__ 0 in
    if not (Ctypes.is_null gerr__)
    then begin
      let msg = getf (!@ gerr__) C.GError.message |> C.strdup in
      C.GError.free gerr__;
      failwith msg
    end;
    res

  let append_value t =
    let gerr__ = CArray.make (ptr C.GError.t) 1 in
    let res = C.ListArrayBuilder.append_value t (CArray.start gerr__) in
    let gerr__ = CArray.get gerr__ 0 in
    if not (Ctypes.is_null gerr__)
    then begin
      let msg = getf (!@ gerr__) C.GError.message |> C.strdup in
      C.GError.free gerr__;
      failwith msg
    end;
    res

  let get_value_builder t =
    let res = C.ListArrayBuilder.get_value_builder t in
    res

end

module ListDataType = struct
  type t = list_data_type
  let new_ field =
    let res = C.ListDataType.new_ field in
    res

  let get_field t =
    let res = C.ListDataType.get_field t in
    res

end

module MemoryMappedInputStream = struct
  type t = memory_mapped_input_stream
  let new_ path =
    let gerr__ = CArray.make (ptr C.GError.t) 1 in
    let res = C.MemoryMappedInputStream.new_ path (CArray.start gerr__) in
    let gerr__ = CArray.get gerr__ 0 in
    if not (Ctypes.is_null gerr__)
    then begin
      let msg = getf (!@ gerr__) C.GError.message |> C.strdup in
      C.GError.free gerr__;
      failwith msg
    end;
    res

end

module MutableBuffer = struct
  type t = mutable_buffer
  let slice t offset size =
    let res = C.MutableBuffer.slice t offset size in
    res

end

module NullArray = struct
  type t = null_array
  let new_ length =
    let res = C.NullArray.new_ length in
    res

end

module NullArrayBuilder = struct
  type t = null_array_builder
  let new_ () =
    let res = C.NullArrayBuilder.new_ () in
    res

  let append_null t =
    let gerr__ = CArray.make (ptr C.GError.t) 1 in
    let res = C.NullArrayBuilder.append_null t (CArray.start gerr__) in
    let gerr__ = CArray.get gerr__ 0 in
    if not (Ctypes.is_null gerr__)
    then begin
      let msg = getf (!@ gerr__) C.GError.message |> C.strdup in
      C.GError.free gerr__;
      failwith msg
    end;
    res

  let append_nulls t n =
    let gerr__ = CArray.make (ptr C.GError.t) 1 in
    let res = C.NullArrayBuilder.append_nulls t n (CArray.start gerr__) in
    let gerr__ = CArray.get gerr__ 0 in
    if not (Ctypes.is_null gerr__)
    then begin
      let msg = getf (!@ gerr__) C.GError.message |> C.strdup in
      C.GError.free gerr__;
      failwith msg
    end;
    res

end

module NullDataType = struct
  type t = null_data_type
  let new_ () =
    let res = C.NullDataType.new_ () in
    res

end

module NumericArray = struct
  type t = numeric_array
  let mean t =
    let gerr__ = CArray.make (ptr C.GError.t) 1 in
    let res = C.NumericArray.mean t (CArray.start gerr__) in
    let gerr__ = CArray.get gerr__ 0 in
    if not (Ctypes.is_null gerr__)
    then begin
      let msg = getf (!@ gerr__) C.GError.message |> C.strdup in
      C.GError.free gerr__;
      failwith msg
    end;
    res

end

module NumericDataType = struct
  type t = numeric_data_type
end

module OutputStream = struct
  type t = output_stream
  let write_tensor t tensor =
    let gerr__ = CArray.make (ptr C.GError.t) 1 in
    let res = C.OutputStream.write_tensor t tensor (CArray.start gerr__) in
    let gerr__ = CArray.get gerr__ 0 in
    if not (Ctypes.is_null gerr__)
    then begin
      let msg = getf (!@ gerr__) C.GError.message |> C.strdup in
      C.GError.free gerr__;
      failwith msg
    end;
    res

end

module PrimitiveArray = struct
  type t = primitive_array
  let get_buffer t =
    let res = C.PrimitiveArray.get_buffer t in
    res

end

module RecordBatch = struct
  type t = record_batch
  let equal t other_record_batch =
    let res = C.RecordBatch.equal t other_record_batch in
    res

  let get_n_rows t =
    let res = C.RecordBatch.get_n_rows t in
    res

  let get_schema t =
    let res = C.RecordBatch.get_schema t in
    res

  let slice t offset length =
    let res = C.RecordBatch.slice t offset length in
    res

  let to_string t =
    let gerr__ = CArray.make (ptr C.GError.t) 1 in
    let res = C.RecordBatch.to_string t (CArray.start gerr__) in
    let gerr__ = CArray.get gerr__ 0 in
    if not (Ctypes.is_null gerr__)
    then begin
      let msg = getf (!@ gerr__) C.GError.message |> C.strdup in
      C.GError.free gerr__;
      failwith msg
    end;
    res

end

module RecordBatchBuilder = struct
  type t = record_batch_builder
  let new_ schema =
    let gerr__ = CArray.make (ptr C.GError.t) 1 in
    let res = C.RecordBatchBuilder.new_ schema (CArray.start gerr__) in
    let gerr__ = CArray.get gerr__ 0 in
    if not (Ctypes.is_null gerr__)
    then begin
      let msg = getf (!@ gerr__) C.GError.message |> C.strdup in
      C.GError.free gerr__;
      failwith msg
    end;
    res

  let flush t =
    let gerr__ = CArray.make (ptr C.GError.t) 1 in
    let res = C.RecordBatchBuilder.flush t (CArray.start gerr__) in
    let gerr__ = CArray.get gerr__ 0 in
    if not (Ctypes.is_null gerr__)
    then begin
      let msg = getf (!@ gerr__) C.GError.message |> C.strdup in
      C.GError.free gerr__;
      failwith msg
    end;
    res

  let get_initial_capacity t =
    let res = C.RecordBatchBuilder.get_initial_capacity t in
    res

  let get_schema t =
    let res = C.RecordBatchBuilder.get_schema t in
    res

end

module RecordBatchFileReader = struct
  type t = record_batch_file_reader
  let new_ file =
    let gerr__ = CArray.make (ptr C.GError.t) 1 in
    let res = C.RecordBatchFileReader.new_ file (CArray.start gerr__) in
    let gerr__ = CArray.get gerr__ 0 in
    if not (Ctypes.is_null gerr__)
    then begin
      let msg = getf (!@ gerr__) C.GError.message |> C.strdup in
      C.GError.free gerr__;
      failwith msg
    end;
    res

  let get_schema t =
    let res = C.RecordBatchFileReader.get_schema t in
    res

end

module RecordBatchFileWriter = struct
  type t = record_batch_file_writer
  let new_ sink schema =
    let gerr__ = CArray.make (ptr C.GError.t) 1 in
    let res = C.RecordBatchFileWriter.new_ sink schema (CArray.start gerr__) in
    let gerr__ = CArray.get gerr__ 0 in
    if not (Ctypes.is_null gerr__)
    then begin
      let msg = getf (!@ gerr__) C.GError.message |> C.strdup in
      C.GError.free gerr__;
      failwith msg
    end;
    res

end

module RecordBatchReader = struct
  type t = record_batch_reader
  let get_schema t =
    let res = C.RecordBatchReader.get_schema t in
    res

  let read_next t =
    let gerr__ = CArray.make (ptr C.GError.t) 1 in
    let res = C.RecordBatchReader.read_next t (CArray.start gerr__) in
    let gerr__ = CArray.get gerr__ 0 in
    if not (Ctypes.is_null gerr__)
    then begin
      let msg = getf (!@ gerr__) C.GError.message |> C.strdup in
      C.GError.free gerr__;
      failwith msg
    end;
    res

end

module RecordBatchStreamReader = struct
  type t = record_batch_stream_reader
  let new_ stream =
    let gerr__ = CArray.make (ptr C.GError.t) 1 in
    let res = C.RecordBatchStreamReader.new_ stream (CArray.start gerr__) in
    let gerr__ = CArray.get gerr__ 0 in
    if not (Ctypes.is_null gerr__)
    then begin
      let msg = getf (!@ gerr__) C.GError.message |> C.strdup in
      C.GError.free gerr__;
      failwith msg
    end;
    res

end

module RecordBatchStreamWriter = struct
  type t = record_batch_stream_writer
  let new_ sink schema =
    let gerr__ = CArray.make (ptr C.GError.t) 1 in
    let res = C.RecordBatchStreamWriter.new_ sink schema (CArray.start gerr__) in
    let gerr__ = CArray.get gerr__ 0 in
    if not (Ctypes.is_null gerr__)
    then begin
      let msg = getf (!@ gerr__) C.GError.message |> C.strdup in
      C.GError.free gerr__;
      failwith msg
    end;
    res

end

module RecordBatchWriter = struct
  type t = record_batch_writer
  let close t =
    let gerr__ = CArray.make (ptr C.GError.t) 1 in
    let res = C.RecordBatchWriter.close t (CArray.start gerr__) in
    let gerr__ = CArray.get gerr__ 0 in
    if not (Ctypes.is_null gerr__)
    then begin
      let msg = getf (!@ gerr__) C.GError.message |> C.strdup in
      C.GError.free gerr__;
      failwith msg
    end;
    res

  let write_record_batch t record_batch =
    let gerr__ = CArray.make (ptr C.GError.t) 1 in
    let res = C.RecordBatchWriter.write_record_batch t record_batch (CArray.start gerr__) in
    let gerr__ = CArray.get gerr__ 0 in
    if not (Ctypes.is_null gerr__)
    then begin
      let msg = getf (!@ gerr__) C.GError.message |> C.strdup in
      C.GError.free gerr__;
      failwith msg
    end;
    res

  let write_table t table =
    let gerr__ = CArray.make (ptr C.GError.t) 1 in
    let res = C.RecordBatchWriter.write_table t table (CArray.start gerr__) in
    let gerr__ = CArray.get gerr__ 0 in
    if not (Ctypes.is_null gerr__)
    then begin
      let msg = getf (!@ gerr__) C.GError.message |> C.strdup in
      C.GError.free gerr__;
      failwith msg
    end;
    res

end

module ResizableBuffer = struct
  type t = resizable_buffer
  let new_ initial_size =
    let gerr__ = CArray.make (ptr C.GError.t) 1 in
    let res = C.ResizableBuffer.new_ initial_size (CArray.start gerr__) in
    let gerr__ = CArray.get gerr__ 0 in
    if not (Ctypes.is_null gerr__)
    then begin
      let msg = getf (!@ gerr__) C.GError.message |> C.strdup in
      C.GError.free gerr__;
      failwith msg
    end;
    res

  let reserve t new_capacity =
    let gerr__ = CArray.make (ptr C.GError.t) 1 in
    let res = C.ResizableBuffer.reserve t new_capacity (CArray.start gerr__) in
    let gerr__ = CArray.get gerr__ 0 in
    if not (Ctypes.is_null gerr__)
    then begin
      let msg = getf (!@ gerr__) C.GError.message |> C.strdup in
      C.GError.free gerr__;
      failwith msg
    end;
    res

  let resize t new_size =
    let gerr__ = CArray.make (ptr C.GError.t) 1 in
    let res = C.ResizableBuffer.resize t new_size (CArray.start gerr__) in
    let gerr__ = CArray.get gerr__ 0 in
    if not (Ctypes.is_null gerr__)
    then begin
      let msg = getf (!@ gerr__) C.GError.message |> C.strdup in
      C.GError.free gerr__;
      failwith msg
    end;
    res

end

module Schema = struct
  type t = schema
  let equal t other_schema =
    let res = C.Schema.equal t other_schema in
    res

  let get_field_by_name t name =
    let res = C.Schema.get_field_by_name t name in
    res

  let to_string t =
    let res = C.Schema.to_string t in
    res

end

module SeekableInputStream = struct
  type t = seekable_input_stream
  let get_support_zero_copy t =
    let res = C.SeekableInputStream.get_support_zero_copy t in
    res

  let read_at t position n_bytes =
    let gerr__ = CArray.make (ptr C.GError.t) 1 in
    let res = C.SeekableInputStream.read_at t position n_bytes (CArray.start gerr__) in
    let gerr__ = CArray.get gerr__ 0 in
    if not (Ctypes.is_null gerr__)
    then begin
      let msg = getf (!@ gerr__) C.GError.message |> C.strdup in
      C.GError.free gerr__;
      failwith msg
    end;
    res

end

module SparseUnionArray = struct
  type t = sparse_union_array
end

module SparseUnionDataType = struct
  type t = sparse_union_data_type
end

module StringArray = struct
  type t = string_array
  let new_ length value_offsets data null_bitmap n_nulls =
    let res = C.StringArray.new_ length value_offsets data null_bitmap n_nulls in
    res

  let get_string t i =
    let res = C.StringArray.get_string t i in
    res

end

module StringArrayBuilder = struct
  type t = string_array_builder
  let new_ () =
    let res = C.StringArrayBuilder.new_ () in
    res

  let append_value t value =
    let gerr__ = CArray.make (ptr C.GError.t) 1 in
    let res = C.StringArrayBuilder.append_value t value (CArray.start gerr__) in
    let gerr__ = CArray.get gerr__ 0 in
    if not (Ctypes.is_null gerr__)
    then begin
      let msg = getf (!@ gerr__) C.GError.message |> C.strdup in
      C.GError.free gerr__;
      failwith msg
    end;
    res

end

module StringDataType = struct
  type t = string_data_type
  let new_ () =
    let res = C.StringDataType.new_ () in
    res

end

module StructArray = struct
  type t = struct_array
end

module StructArrayBuilder = struct
  type t = struct_array_builder
  let new_ data_type =
    let gerr__ = CArray.make (ptr C.GError.t) 1 in
    let res = C.StructArrayBuilder.new_ data_type (CArray.start gerr__) in
    let gerr__ = CArray.get gerr__ 0 in
    if not (Ctypes.is_null gerr__)
    then begin
      let msg = getf (!@ gerr__) C.GError.message |> C.strdup in
      C.GError.free gerr__;
      failwith msg
    end;
    res

  let append_null t =
    let gerr__ = CArray.make (ptr C.GError.t) 1 in
    let res = C.StructArrayBuilder.append_null t (CArray.start gerr__) in
    let gerr__ = CArray.get gerr__ 0 in
    if not (Ctypes.is_null gerr__)
    then begin
      let msg = getf (!@ gerr__) C.GError.message |> C.strdup in
      C.GError.free gerr__;
      failwith msg
    end;
    res

  let append_value t =
    let gerr__ = CArray.make (ptr C.GError.t) 1 in
    let res = C.StructArrayBuilder.append_value t (CArray.start gerr__) in
    let gerr__ = CArray.get gerr__ 0 in
    if not (Ctypes.is_null gerr__)
    then begin
      let msg = getf (!@ gerr__) C.GError.message |> C.strdup in
      C.GError.free gerr__;
      failwith msg
    end;
    res

end

module StructDataType = struct
  type t = struct_data_type
  let get_field_by_name t name =
    let res = C.StructDataType.get_field_by_name t name in
    res

end

module Table = struct
  type t = table
  let equal t other_table =
    let res = C.Table.equal t other_table in
    res

  let get_schema t =
    let res = C.Table.get_schema t in
    res

  let to_string t =
    let gerr__ = CArray.make (ptr C.GError.t) 1 in
    let res = C.Table.to_string t (CArray.start gerr__) in
    let gerr__ = CArray.get gerr__ 0 in
    if not (Ctypes.is_null gerr__)
    then begin
      let msg = getf (!@ gerr__) C.GError.message |> C.strdup in
      C.GError.free gerr__;
      failwith msg
    end;
    res

end

module TableBatchReader = struct
  type t = table_batch_reader
  let new_ table =
    let res = C.TableBatchReader.new_ table in
    res

end

module Tensor = struct
  type t = tensor
  let equal t other_tensor =
    let res = C.Tensor.equal t other_tensor in
    res

  let get_buffer t =
    let res = C.Tensor.get_buffer t in
    res

  let get_size t =
    let res = C.Tensor.get_size t in
    res

  let get_value_data_type t =
    let res = C.Tensor.get_value_data_type t in
    res

  let is_column_major t =
    let res = C.Tensor.is_column_major t in
    res

  let is_contiguous t =
    let res = C.Tensor.is_contiguous t in
    res

  let is_mutable t =
    let res = C.Tensor.is_mutable t in
    res

  let is_row_major t =
    let res = C.Tensor.is_row_major t in
    res

end

module Time32Array = struct
  type t = time32_array
  let new_ data_type length data null_bitmap n_nulls =
    let res = C.Time32Array.new_ data_type length data null_bitmap n_nulls in
    res

end

module Time32ArrayBuilder = struct
  type t = time32_array_builder
  let new_ data_type =
    let res = C.Time32ArrayBuilder.new_ data_type in
    res

  let append_null t =
    let gerr__ = CArray.make (ptr C.GError.t) 1 in
    let res = C.Time32ArrayBuilder.append_null t (CArray.start gerr__) in
    let gerr__ = CArray.get gerr__ 0 in
    if not (Ctypes.is_null gerr__)
    then begin
      let msg = getf (!@ gerr__) C.GError.message |> C.strdup in
      C.GError.free gerr__;
      failwith msg
    end;
    res

  let append_nulls t n =
    let gerr__ = CArray.make (ptr C.GError.t) 1 in
    let res = C.Time32ArrayBuilder.append_nulls t n (CArray.start gerr__) in
    let gerr__ = CArray.get gerr__ 0 in
    if not (Ctypes.is_null gerr__)
    then begin
      let msg = getf (!@ gerr__) C.GError.message |> C.strdup in
      C.GError.free gerr__;
      failwith msg
    end;
    res

end

module Time32DataType = struct
  type t = time32_data_type
end

module Time64Array = struct
  type t = time64_array
  let new_ data_type length data null_bitmap n_nulls =
    let res = C.Time64Array.new_ data_type length data null_bitmap n_nulls in
    res

  let get_value t i =
    let res = C.Time64Array.get_value t i in
    res

end

module Time64ArrayBuilder = struct
  type t = time64_array_builder
  let new_ data_type =
    let res = C.Time64ArrayBuilder.new_ data_type in
    res

  let append_null t =
    let gerr__ = CArray.make (ptr C.GError.t) 1 in
    let res = C.Time64ArrayBuilder.append_null t (CArray.start gerr__) in
    let gerr__ = CArray.get gerr__ 0 in
    if not (Ctypes.is_null gerr__)
    then begin
      let msg = getf (!@ gerr__) C.GError.message |> C.strdup in
      C.GError.free gerr__;
      failwith msg
    end;
    res

  let append_nulls t n =
    let gerr__ = CArray.make (ptr C.GError.t) 1 in
    let res = C.Time64ArrayBuilder.append_nulls t n (CArray.start gerr__) in
    let gerr__ = CArray.get gerr__ 0 in
    if not (Ctypes.is_null gerr__)
    then begin
      let msg = getf (!@ gerr__) C.GError.message |> C.strdup in
      C.GError.free gerr__;
      failwith msg
    end;
    res

  let append_value t value =
    let gerr__ = CArray.make (ptr C.GError.t) 1 in
    let res = C.Time64ArrayBuilder.append_value t value (CArray.start gerr__) in
    let gerr__ = CArray.get gerr__ 0 in
    if not (Ctypes.is_null gerr__)
    then begin
      let msg = getf (!@ gerr__) C.GError.message |> C.strdup in
      C.GError.free gerr__;
      failwith msg
    end;
    res

end

module Time64DataType = struct
  type t = time64_data_type
end

module TimeDataType = struct
  type t = time_data_type
end

module TimestampArray = struct
  type t = timestamp_array
  let new_ data_type length data null_bitmap n_nulls =
    let res = C.TimestampArray.new_ data_type length data null_bitmap n_nulls in
    res

  let get_value t i =
    let res = C.TimestampArray.get_value t i in
    res

end

module TimestampArrayBuilder = struct
  type t = timestamp_array_builder
  let new_ data_type =
    let res = C.TimestampArrayBuilder.new_ data_type in
    res

  let append_null t =
    let gerr__ = CArray.make (ptr C.GError.t) 1 in
    let res = C.TimestampArrayBuilder.append_null t (CArray.start gerr__) in
    let gerr__ = CArray.get gerr__ 0 in
    if not (Ctypes.is_null gerr__)
    then begin
      let msg = getf (!@ gerr__) C.GError.message |> C.strdup in
      C.GError.free gerr__;
      failwith msg
    end;
    res

  let append_nulls t n =
    let gerr__ = CArray.make (ptr C.GError.t) 1 in
    let res = C.TimestampArrayBuilder.append_nulls t n (CArray.start gerr__) in
    let gerr__ = CArray.get gerr__ 0 in
    if not (Ctypes.is_null gerr__)
    then begin
      let msg = getf (!@ gerr__) C.GError.message |> C.strdup in
      C.GError.free gerr__;
      failwith msg
    end;
    res

  let append_value t value =
    let gerr__ = CArray.make (ptr C.GError.t) 1 in
    let res = C.TimestampArrayBuilder.append_value t value (CArray.start gerr__) in
    let gerr__ = CArray.get gerr__ 0 in
    if not (Ctypes.is_null gerr__)
    then begin
      let msg = getf (!@ gerr__) C.GError.message |> C.strdup in
      C.GError.free gerr__;
      failwith msg
    end;
    res

end

module TimestampDataType = struct
  type t = timestamp_data_type
end

module UInt16Array = struct
  type t = u_int16_array
  let new_ length data null_bitmap n_nulls =
    let res = C.UInt16Array.new_ length data null_bitmap n_nulls in
    res

end

module UInt16ArrayBuilder = struct
  type t = u_int16_array_builder
  let new_ () =
    let res = C.UInt16ArrayBuilder.new_ () in
    res

  let append_null t =
    let gerr__ = CArray.make (ptr C.GError.t) 1 in
    let res = C.UInt16ArrayBuilder.append_null t (CArray.start gerr__) in
    let gerr__ = CArray.get gerr__ 0 in
    if not (Ctypes.is_null gerr__)
    then begin
      let msg = getf (!@ gerr__) C.GError.message |> C.strdup in
      C.GError.free gerr__;
      failwith msg
    end;
    res

  let append_nulls t n =
    let gerr__ = CArray.make (ptr C.GError.t) 1 in
    let res = C.UInt16ArrayBuilder.append_nulls t n (CArray.start gerr__) in
    let gerr__ = CArray.get gerr__ 0 in
    if not (Ctypes.is_null gerr__)
    then begin
      let msg = getf (!@ gerr__) C.GError.message |> C.strdup in
      C.GError.free gerr__;
      failwith msg
    end;
    res

end

module UInt16DataType = struct
  type t = u_int16_data_type
  let new_ () =
    let res = C.UInt16DataType.new_ () in
    res

end

module UInt32Array = struct
  type t = u_int32_array
  let new_ length data null_bitmap n_nulls =
    let res = C.UInt32Array.new_ length data null_bitmap n_nulls in
    res

end

module UInt32ArrayBuilder = struct
  type t = u_int32_array_builder
  let new_ () =
    let res = C.UInt32ArrayBuilder.new_ () in
    res

  let append_null t =
    let gerr__ = CArray.make (ptr C.GError.t) 1 in
    let res = C.UInt32ArrayBuilder.append_null t (CArray.start gerr__) in
    let gerr__ = CArray.get gerr__ 0 in
    if not (Ctypes.is_null gerr__)
    then begin
      let msg = getf (!@ gerr__) C.GError.message |> C.strdup in
      C.GError.free gerr__;
      failwith msg
    end;
    res

  let append_nulls t n =
    let gerr__ = CArray.make (ptr C.GError.t) 1 in
    let res = C.UInt32ArrayBuilder.append_nulls t n (CArray.start gerr__) in
    let gerr__ = CArray.get gerr__ 0 in
    if not (Ctypes.is_null gerr__)
    then begin
      let msg = getf (!@ gerr__) C.GError.message |> C.strdup in
      C.GError.free gerr__;
      failwith msg
    end;
    res

end

module UInt32DataType = struct
  type t = u_int32_data_type
  let new_ () =
    let res = C.UInt32DataType.new_ () in
    res

end

module UInt64Array = struct
  type t = u_int64_array
  let new_ length data null_bitmap n_nulls =
    let res = C.UInt64Array.new_ length data null_bitmap n_nulls in
    res

end

module UInt64ArrayBuilder = struct
  type t = u_int64_array_builder
  let new_ () =
    let res = C.UInt64ArrayBuilder.new_ () in
    res

  let append_null t =
    let gerr__ = CArray.make (ptr C.GError.t) 1 in
    let res = C.UInt64ArrayBuilder.append_null t (CArray.start gerr__) in
    let gerr__ = CArray.get gerr__ 0 in
    if not (Ctypes.is_null gerr__)
    then begin
      let msg = getf (!@ gerr__) C.GError.message |> C.strdup in
      C.GError.free gerr__;
      failwith msg
    end;
    res

  let append_nulls t n =
    let gerr__ = CArray.make (ptr C.GError.t) 1 in
    let res = C.UInt64ArrayBuilder.append_nulls t n (CArray.start gerr__) in
    let gerr__ = CArray.get gerr__ 0 in
    if not (Ctypes.is_null gerr__)
    then begin
      let msg = getf (!@ gerr__) C.GError.message |> C.strdup in
      C.GError.free gerr__;
      failwith msg
    end;
    res

end

module UInt64DataType = struct
  type t = u_int64_data_type
  let new_ () =
    let res = C.UInt64DataType.new_ () in
    res

end

module UInt8Array = struct
  type t = u_int8_array
  let new_ length data null_bitmap n_nulls =
    let res = C.UInt8Array.new_ length data null_bitmap n_nulls in
    res

end

module UInt8ArrayBuilder = struct
  type t = u_int8_array_builder
  let new_ () =
    let res = C.UInt8ArrayBuilder.new_ () in
    res

  let append_null t =
    let gerr__ = CArray.make (ptr C.GError.t) 1 in
    let res = C.UInt8ArrayBuilder.append_null t (CArray.start gerr__) in
    let gerr__ = CArray.get gerr__ 0 in
    if not (Ctypes.is_null gerr__)
    then begin
      let msg = getf (!@ gerr__) C.GError.message |> C.strdup in
      C.GError.free gerr__;
      failwith msg
    end;
    res

  let append_nulls t n =
    let gerr__ = CArray.make (ptr C.GError.t) 1 in
    let res = C.UInt8ArrayBuilder.append_nulls t n (CArray.start gerr__) in
    let gerr__ = CArray.get gerr__ 0 in
    if not (Ctypes.is_null gerr__)
    then begin
      let msg = getf (!@ gerr__) C.GError.message |> C.strdup in
      C.GError.free gerr__;
      failwith msg
    end;
    res

end

module UInt8DataType = struct
  type t = u_int8_data_type
  let new_ () =
    let res = C.UInt8DataType.new_ () in
    res

end

module UIntArrayBuilder = struct
  type t = u_int_array_builder
  let new_ () =
    let res = C.UIntArrayBuilder.new_ () in
    res

  let append_null t =
    let gerr__ = CArray.make (ptr C.GError.t) 1 in
    let res = C.UIntArrayBuilder.append_null t (CArray.start gerr__) in
    let gerr__ = CArray.get gerr__ 0 in
    if not (Ctypes.is_null gerr__)
    then begin
      let msg = getf (!@ gerr__) C.GError.message |> C.strdup in
      C.GError.free gerr__;
      failwith msg
    end;
    res

  let append_nulls t n =
    let gerr__ = CArray.make (ptr C.GError.t) 1 in
    let res = C.UIntArrayBuilder.append_nulls t n (CArray.start gerr__) in
    let gerr__ = CArray.get gerr__ 0 in
    if not (Ctypes.is_null gerr__)
    then begin
      let msg = getf (!@ gerr__) C.GError.message |> C.strdup in
      C.GError.free gerr__;
      failwith msg
    end;
    res

end

module UnionArray = struct
  type t = union_array
end

module UnionDataType = struct
  type t = union_data_type
end

