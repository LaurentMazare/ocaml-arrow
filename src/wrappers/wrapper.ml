(* THIS FILE IS AUTOMATICALLY GENERATED, DO NOT EDIT! *)

open Ctypes
module C = Arrow_bindings.C (Arrow_generated)

type _ gobject = C.gobject


module Array = struct
  type t = [ `array_ ] gobject
  let of_gobject g =
    if C.Array.get_type () = C.gobject_type g
    then Some g else None

  let cast ?options t__ target_data_type =
    let gerr__ = CArray.make (ptr C.GError.t) 1 in
    let res = C.Array.cast t__ target_data_type (match options with | None -> null | Some v -> v) (CArray.start gerr__) in
    let gerr__ = CArray.get gerr__ 0 in
    if not (Ctypes.is_null gerr__)
    then begin
      let msg = getf (!@ gerr__) C.GError.message in
      if Ctypes.is_null msg
      then failwith "failed with null error message";
      let msg = C.strdup msg in
      C.GError.free gerr__;
      failwith msg
    end;
    if Ctypes.is_null res
    then failwith "returned null";
    Gc.finalise C.object_unref res;
    res

  let count ?options t__ =
    let gerr__ = CArray.make (ptr C.GError.t) 1 in
    let res = C.Array.count t__ (match options with | None -> null | Some v -> v) (CArray.start gerr__) in
    let gerr__ = CArray.get gerr__ 0 in
    if not (Ctypes.is_null gerr__)
    then begin
      let msg = getf (!@ gerr__) C.GError.message in
      if Ctypes.is_null msg
      then failwith "failed with null error message";
      let msg = C.strdup msg in
      C.GError.free gerr__;
      failwith msg
    end;
    res

  let count_values t__ =
    let gerr__ = CArray.make (ptr C.GError.t) 1 in
    let res = C.Array.count_values t__ (CArray.start gerr__) in
    let gerr__ = CArray.get gerr__ 0 in
    if not (Ctypes.is_null gerr__)
    then begin
      let msg = getf (!@ gerr__) C.GError.message in
      if Ctypes.is_null msg
      then failwith "failed with null error message";
      let msg = C.strdup msg in
      C.GError.free gerr__;
      failwith msg
    end;
    if Ctypes.is_null res
    then failwith "returned null";
    Gc.finalise C.object_unref res;
    res

  let dictionary_encode t__ =
    let gerr__ = CArray.make (ptr C.GError.t) 1 in
    let res = C.Array.dictionary_encode t__ (CArray.start gerr__) in
    let gerr__ = CArray.get gerr__ 0 in
    if not (Ctypes.is_null gerr__)
    then begin
      let msg = getf (!@ gerr__) C.GError.message in
      if Ctypes.is_null msg
      then failwith "failed with null error message";
      let msg = C.strdup msg in
      C.GError.free gerr__;
      failwith msg
    end;
    if Ctypes.is_null res
    then failwith "returned null";
    Gc.finalise C.object_unref res;
    res

  let equal t__ other_array =
    let res = C.Array.equal t__ other_array in
    res

  let equal_approx t__ other_array =
    let res = C.Array.equal_approx t__ other_array in
    res

  let equal_range t__ start_index other_array other_start_index end_index =
    let res = C.Array.equal_range t__ start_index other_array other_start_index end_index in
    res

  let get_length t__ =
    let res = C.Array.get_length t__ in
    res

  let get_n_nulls t__ =
    let res = C.Array.get_n_nulls t__ in
    res

  let get_null_bitmap t__ =
    let res = C.Array.get_null_bitmap t__ in
    if Ctypes.is_null res
    then failwith "returned null";
    Gc.finalise C.object_unref res;
    res

  let get_offset t__ =
    let res = C.Array.get_offset t__ in
    res

  let get_value_data_type t__ =
    let res = C.Array.get_value_data_type t__ in
    if Ctypes.is_null res
    then failwith "returned null";
    Gc.finalise C.object_unref res;
    res

  let is_null t__ i =
    let res = C.Array.is_null t__ i in
    res

  let is_valid t__ i =
    let res = C.Array.is_valid t__ i in
    res

  let slice t__ offset length =
    let res = C.Array.slice t__ offset length in
    if Ctypes.is_null res
    then failwith "returned null";
    Gc.finalise C.object_unref res;
    res

  let to_string t__ =
    let gerr__ = CArray.make (ptr C.GError.t) 1 in
    let res = C.Array.to_string t__ (CArray.start gerr__) in
    let gerr__ = CArray.get gerr__ 0 in
    if not (Ctypes.is_null gerr__)
    then begin
      let msg = getf (!@ gerr__) C.GError.message in
      if Ctypes.is_null msg
      then failwith "failed with null error message";
      let msg = C.strdup msg in
      C.GError.free gerr__;
      failwith msg
    end;
    res

  let unique t__ =
    let gerr__ = CArray.make (ptr C.GError.t) 1 in
    let res = C.Array.unique t__ (CArray.start gerr__) in
    let gerr__ = CArray.get gerr__ 0 in
    if not (Ctypes.is_null gerr__)
    then begin
      let msg = getf (!@ gerr__) C.GError.message in
      if Ctypes.is_null msg
      then failwith "failed with null error message";
      let msg = C.strdup msg in
      C.GError.free gerr__;
      failwith msg
    end;
    if Ctypes.is_null res
    then failwith "returned null";
    Gc.finalise C.object_unref res;
    res

end

module ArrayBuilder = struct
  type t = [ `array_builder ] gobject
  let of_gobject g =
    if C.ArrayBuilder.get_type () = C.gobject_type g
    then Some g else None

  let finish t__ =
    let gerr__ = CArray.make (ptr C.GError.t) 1 in
    let res = C.ArrayBuilder.finish t__ (CArray.start gerr__) in
    let gerr__ = CArray.get gerr__ 0 in
    if not (Ctypes.is_null gerr__)
    then begin
      let msg = getf (!@ gerr__) C.GError.message in
      if Ctypes.is_null msg
      then failwith "failed with null error message";
      let msg = C.strdup msg in
      C.GError.free gerr__;
      failwith msg
    end;
    if Ctypes.is_null res
    then failwith "returned null";
    Gc.finalise C.object_unref res;
    res

  let get_value_data_type t__ =
    let res = C.ArrayBuilder.get_value_data_type t__ in
    if Ctypes.is_null res
    then failwith "returned null";
    Gc.finalise C.object_unref res;
    res

end

module BinaryArray = struct
  type t = [ `binary_array | `array_ ] gobject
  let of_gobject g =
    if C.BinaryArray.get_type () = C.gobject_type g
    then Some g else None

  let new_ ?null_bitmap length value_offsets data n_nulls =
    let res = C.BinaryArray.new_ length value_offsets data (match null_bitmap with | None -> null | Some v -> v) n_nulls in
    if Ctypes.is_null res
    then failwith "returned null";
    Gc.finalise C.object_unref res;
    res

  let get_buffer t__ =
    let res = C.BinaryArray.get_buffer t__ in
    if Ctypes.is_null res
    then failwith "returned null";
    Gc.finalise C.object_unref res;
    res

  let get_offsets_buffer t__ =
    let res = C.BinaryArray.get_offsets_buffer t__ in
    if Ctypes.is_null res
    then failwith "returned null";
    Gc.finalise C.object_unref res;
    res

end

module BinaryArrayBuilder = struct
  type t = [ `binary_array_builder | `array_builder ] gobject
  let of_gobject g =
    if C.BinaryArrayBuilder.get_type () = C.gobject_type g
    then Some g else None

  let new_ () =
    let res = C.BinaryArrayBuilder.new_ () in
    if Ctypes.is_null res
    then failwith "returned null";
    Gc.finalise C.object_unref res;
    res

  let append_null t__ =
    let gerr__ = CArray.make (ptr C.GError.t) 1 in
    let res = C.BinaryArrayBuilder.append_null t__ (CArray.start gerr__) in
    let gerr__ = CArray.get gerr__ 0 in
    if not (Ctypes.is_null gerr__)
    then begin
      let msg = getf (!@ gerr__) C.GError.message in
      if Ctypes.is_null msg
      then failwith "failed with null error message";
      let msg = C.strdup msg in
      C.GError.free gerr__;
      failwith msg
    end;
    res

end

module BinaryDataType = struct
  type t = [ `binary_data_type | `data_type ] gobject
  let of_gobject g =
    if C.BinaryDataType.get_type () = C.gobject_type g
    then Some g else None

  let new_ () =
    let res = C.BinaryDataType.new_ () in
    if Ctypes.is_null res
    then failwith "returned null";
    Gc.finalise C.object_unref res;
    res

end

module BooleanArray = struct
  type t = [ `boolean_array | `primitive_array | `array_ ] gobject
  let of_gobject g =
    if C.BooleanArray.get_type () = C.gobject_type g
    then Some g else None

  let new_ ?null_bitmap length data n_nulls =
    let res = C.BooleanArray.new_ length data (match null_bitmap with | None -> null | Some v -> v) n_nulls in
    if Ctypes.is_null res
    then failwith "returned null";
    Gc.finalise C.object_unref res;
    res

  let and_ t__ right =
    let gerr__ = CArray.make (ptr C.GError.t) 1 in
    let res = C.BooleanArray.and_ t__ right (CArray.start gerr__) in
    let gerr__ = CArray.get gerr__ 0 in
    if not (Ctypes.is_null gerr__)
    then begin
      let msg = getf (!@ gerr__) C.GError.message in
      if Ctypes.is_null msg
      then failwith "failed with null error message";
      let msg = C.strdup msg in
      C.GError.free gerr__;
      failwith msg
    end;
    if Ctypes.is_null res
    then failwith "returned null";
    Gc.finalise C.object_unref res;
    res

  let get_value t__ i =
    let res = C.BooleanArray.get_value t__ i in
    res

  let invert t__ =
    let gerr__ = CArray.make (ptr C.GError.t) 1 in
    let res = C.BooleanArray.invert t__ (CArray.start gerr__) in
    let gerr__ = CArray.get gerr__ 0 in
    if not (Ctypes.is_null gerr__)
    then begin
      let msg = getf (!@ gerr__) C.GError.message in
      if Ctypes.is_null msg
      then failwith "failed with null error message";
      let msg = C.strdup msg in
      C.GError.free gerr__;
      failwith msg
    end;
    if Ctypes.is_null res
    then failwith "returned null";
    Gc.finalise C.object_unref res;
    res

  let or_ t__ right =
    let gerr__ = CArray.make (ptr C.GError.t) 1 in
    let res = C.BooleanArray.or_ t__ right (CArray.start gerr__) in
    let gerr__ = CArray.get gerr__ 0 in
    if not (Ctypes.is_null gerr__)
    then begin
      let msg = getf (!@ gerr__) C.GError.message in
      if Ctypes.is_null msg
      then failwith "failed with null error message";
      let msg = C.strdup msg in
      C.GError.free gerr__;
      failwith msg
    end;
    if Ctypes.is_null res
    then failwith "returned null";
    Gc.finalise C.object_unref res;
    res

  let xor t__ right =
    let gerr__ = CArray.make (ptr C.GError.t) 1 in
    let res = C.BooleanArray.xor t__ right (CArray.start gerr__) in
    let gerr__ = CArray.get gerr__ 0 in
    if not (Ctypes.is_null gerr__)
    then begin
      let msg = getf (!@ gerr__) C.GError.message in
      if Ctypes.is_null msg
      then failwith "failed with null error message";
      let msg = C.strdup msg in
      C.GError.free gerr__;
      failwith msg
    end;
    if Ctypes.is_null res
    then failwith "returned null";
    Gc.finalise C.object_unref res;
    res

end

module BooleanArrayBuilder = struct
  type t = [ `boolean_array_builder | `array_builder ] gobject
  let of_gobject g =
    if C.BooleanArrayBuilder.get_type () = C.gobject_type g
    then Some g else None

  let new_ () =
    let res = C.BooleanArrayBuilder.new_ () in
    if Ctypes.is_null res
    then failwith "returned null";
    Gc.finalise C.object_unref res;
    res

  let append_null t__ =
    let gerr__ = CArray.make (ptr C.GError.t) 1 in
    let res = C.BooleanArrayBuilder.append_null t__ (CArray.start gerr__) in
    let gerr__ = CArray.get gerr__ 0 in
    if not (Ctypes.is_null gerr__)
    then begin
      let msg = getf (!@ gerr__) C.GError.message in
      if Ctypes.is_null msg
      then failwith "failed with null error message";
      let msg = C.strdup msg in
      C.GError.free gerr__;
      failwith msg
    end;
    res

  let append_nulls t__ n =
    let gerr__ = CArray.make (ptr C.GError.t) 1 in
    let res = C.BooleanArrayBuilder.append_nulls t__ n (CArray.start gerr__) in
    let gerr__ = CArray.get gerr__ 0 in
    if not (Ctypes.is_null gerr__)
    then begin
      let msg = getf (!@ gerr__) C.GError.message in
      if Ctypes.is_null msg
      then failwith "failed with null error message";
      let msg = C.strdup msg in
      C.GError.free gerr__;
      failwith msg
    end;
    res

  let append_value t__ value =
    let gerr__ = CArray.make (ptr C.GError.t) 1 in
    let res = C.BooleanArrayBuilder.append_value t__ value (CArray.start gerr__) in
    let gerr__ = CArray.get gerr__ 0 in
    if not (Ctypes.is_null gerr__)
    then begin
      let msg = getf (!@ gerr__) C.GError.message in
      if Ctypes.is_null msg
      then failwith "failed with null error message";
      let msg = C.strdup msg in
      C.GError.free gerr__;
      failwith msg
    end;
    res

end

module BooleanDataType = struct
  type t = [ `boolean_data_type | `fixed_width_data_type | `data_type ] gobject
  let of_gobject g =
    if C.BooleanDataType.get_type () = C.gobject_type g
    then Some g else None

  let new_ () =
    let res = C.BooleanDataType.new_ () in
    if Ctypes.is_null res
    then failwith "returned null";
    Gc.finalise C.object_unref res;
    res

end

module Buffer = struct
  type t = [ `buffer ] gobject
  let of_gobject g =
    if C.Buffer.get_type () = C.gobject_type g
    then Some g else None

  let copy t__ start size =
    let gerr__ = CArray.make (ptr C.GError.t) 1 in
    let res = C.Buffer.copy t__ start size (CArray.start gerr__) in
    let gerr__ = CArray.get gerr__ 0 in
    if not (Ctypes.is_null gerr__)
    then begin
      let msg = getf (!@ gerr__) C.GError.message in
      if Ctypes.is_null msg
      then failwith "failed with null error message";
      let msg = C.strdup msg in
      C.GError.free gerr__;
      failwith msg
    end;
    if Ctypes.is_null res
    then failwith "returned null";
    Gc.finalise C.object_unref res;
    res

  let equal t__ other_buffer =
    let res = C.Buffer.equal t__ other_buffer in
    res

  let equal_n_bytes t__ other_buffer n_bytes =
    let res = C.Buffer.equal_n_bytes t__ other_buffer n_bytes in
    res

  let get_capacity t__ =
    let res = C.Buffer.get_capacity t__ in
    res

  let get_parent t__ =
    let res = C.Buffer.get_parent t__ in
    if Ctypes.is_null res
    then failwith "returned null";
    Gc.finalise C.object_unref res;
    res

  let get_size t__ =
    let res = C.Buffer.get_size t__ in
    res

  let is_mutable t__ =
    let res = C.Buffer.is_mutable t__ in
    res

  let slice t__ offset size =
    let res = C.Buffer.slice t__ offset size in
    if Ctypes.is_null res
    then failwith "returned null";
    Gc.finalise C.object_unref res;
    res

end

module BufferInputStream = struct
  type t = [ `buffer_input_stream | `seekable_input_stream | `input_stream ] gobject
  let of_gobject g =
    if C.BufferInputStream.get_type () = C.gobject_type g
    then Some g else None

  let new_ buffer =
    let res = C.BufferInputStream.new_ buffer in
    if Ctypes.is_null res
    then failwith "returned null";
    Gc.finalise C.object_unref res;
    res

  let get_buffer t__ =
    let res = C.BufferInputStream.get_buffer t__ in
    if Ctypes.is_null res
    then failwith "returned null";
    Gc.finalise C.object_unref res;
    res

end

module BufferOutputStream = struct
  type t = [ `buffer_output_stream | `output_stream ] gobject
  let of_gobject g =
    if C.BufferOutputStream.get_type () = C.gobject_type g
    then Some g else None

  let new_ buffer =
    let res = C.BufferOutputStream.new_ buffer in
    if Ctypes.is_null res
    then failwith "returned null";
    Gc.finalise C.object_unref res;
    res

end

module CSVReadOptions = struct
  type t = [ `csv_read_options ] gobject
  let of_gobject g =
    if C.CSVReadOptions.get_type () = C.gobject_type g
    then Some g else None

  let new_ () =
    let res = C.CSVReadOptions.new_ () in
    if Ctypes.is_null res
    then failwith "returned null";
    Gc.finalise C.object_unref res;
    res

end

module CSVReader = struct
  type t = [ `csv_reader ] gobject
  let of_gobject g =
    if C.CSVReader.get_type () = C.gobject_type g
    then Some g else None

  let new_ ?options input =
    let gerr__ = CArray.make (ptr C.GError.t) 1 in
    let res = C.CSVReader.new_ input (match options with | None -> null | Some v -> v) (CArray.start gerr__) in
    let gerr__ = CArray.get gerr__ 0 in
    if not (Ctypes.is_null gerr__)
    then begin
      let msg = getf (!@ gerr__) C.GError.message in
      if Ctypes.is_null msg
      then failwith "failed with null error message";
      let msg = C.strdup msg in
      C.GError.free gerr__;
      failwith msg
    end;
    if Ctypes.is_null res
    then failwith "returned null";
    Gc.finalise C.object_unref res;
    res

  let read t__ =
    let gerr__ = CArray.make (ptr C.GError.t) 1 in
    let res = C.CSVReader.read t__ (CArray.start gerr__) in
    let gerr__ = CArray.get gerr__ 0 in
    if not (Ctypes.is_null gerr__)
    then begin
      let msg = getf (!@ gerr__) C.GError.message in
      if Ctypes.is_null msg
      then failwith "failed with null error message";
      let msg = C.strdup msg in
      C.GError.free gerr__;
      failwith msg
    end;
    if Ctypes.is_null res
    then failwith "returned null";
    Gc.finalise C.object_unref res;
    res

end

module CastOptions = struct
  type t = [ `cast_options ] gobject
  let of_gobject g =
    if C.CastOptions.get_type () = C.gobject_type g
    then Some g else None

  let new_ () =
    let res = C.CastOptions.new_ () in
    if Ctypes.is_null res
    then failwith "returned null";
    Gc.finalise C.object_unref res;
    res

end

module ChunkedArray = struct
  type t = [ `chunked_array ] gobject
  let of_gobject g =
    if C.ChunkedArray.get_type () = C.gobject_type g
    then Some g else None

  let equal t__ other_chunked_array =
    let res = C.ChunkedArray.equal t__ other_chunked_array in
    res

  let get_chunk t__ i =
    let res = C.ChunkedArray.get_chunk t__ i in
    if Ctypes.is_null res
    then failwith "returned null";
    Gc.finalise C.object_unref res;
    res

  let get_length t__ =
    let res = C.ChunkedArray.get_length t__ in
    res

  let get_n_chunks t__ =
    let res = C.ChunkedArray.get_n_chunks t__ in
    res

  let get_n_nulls t__ =
    let res = C.ChunkedArray.get_n_nulls t__ in
    res

  let get_value_data_type t__ =
    let res = C.ChunkedArray.get_value_data_type t__ in
    if Ctypes.is_null res
    then failwith "returned null";
    Gc.finalise C.object_unref res;
    res

  let slice t__ offset length =
    let res = C.ChunkedArray.slice t__ offset length in
    if Ctypes.is_null res
    then failwith "returned null";
    Gc.finalise C.object_unref res;
    res

  let to_string t__ =
    let gerr__ = CArray.make (ptr C.GError.t) 1 in
    let res = C.ChunkedArray.to_string t__ (CArray.start gerr__) in
    let gerr__ = CArray.get gerr__ 0 in
    if not (Ctypes.is_null gerr__)
    then begin
      let msg = getf (!@ gerr__) C.GError.message in
      if Ctypes.is_null msg
      then failwith "failed with null error message";
      let msg = C.strdup msg in
      C.GError.free gerr__;
      failwith msg
    end;
    res

end

module Codec = struct
  type t = [ `codec ] gobject
  let of_gobject g =
    if C.Codec.get_type () = C.gobject_type g
    then Some g else None

  let get_name t__ =
    let res = C.Codec.get_name t__ in
    res

end

module Column = struct
  type t = [ `column ] gobject
  let of_gobject g =
    if C.Column.get_type () = C.gobject_type g
    then Some g else None

  let new_array field array =
    let res = C.Column.new_array field array in
    if Ctypes.is_null res
    then failwith "returned null";
    Gc.finalise C.object_unref res;
    res

  let new_chunked_array field chunked_array =
    let res = C.Column.new_chunked_array field chunked_array in
    if Ctypes.is_null res
    then failwith "returned null";
    Gc.finalise C.object_unref res;
    res

  let equal t__ other_column =
    let res = C.Column.equal t__ other_column in
    res

  let get_data t__ =
    let res = C.Column.get_data t__ in
    if Ctypes.is_null res
    then failwith "returned null";
    Gc.finalise C.object_unref res;
    res

  let get_data_type t__ =
    let res = C.Column.get_data_type t__ in
    if Ctypes.is_null res
    then failwith "returned null";
    Gc.finalise C.object_unref res;
    res

  let get_field t__ =
    let res = C.Column.get_field t__ in
    if Ctypes.is_null res
    then failwith "returned null";
    Gc.finalise C.object_unref res;
    res

  let get_length t__ =
    let res = C.Column.get_length t__ in
    res

  let get_n_nulls t__ =
    let res = C.Column.get_n_nulls t__ in
    res

  let get_name t__ =
    let res = C.Column.get_name t__ in
    res

  let slice t__ offset length =
    let res = C.Column.slice t__ offset length in
    if Ctypes.is_null res
    then failwith "returned null";
    Gc.finalise C.object_unref res;
    res

  let to_string t__ =
    let gerr__ = CArray.make (ptr C.GError.t) 1 in
    let res = C.Column.to_string t__ (CArray.start gerr__) in
    let gerr__ = CArray.get gerr__ 0 in
    if not (Ctypes.is_null gerr__)
    then begin
      let msg = getf (!@ gerr__) C.GError.message in
      if Ctypes.is_null msg
      then failwith "failed with null error message";
      let msg = C.strdup msg in
      C.GError.free gerr__;
      failwith msg
    end;
    res

end

module CompressedInputStream = struct
  type t = [ `compressed_input_stream | `input_stream ] gobject
  let of_gobject g =
    if C.CompressedInputStream.get_type () = C.gobject_type g
    then Some g else None

  let new_ codec raw =
    let gerr__ = CArray.make (ptr C.GError.t) 1 in
    let res = C.CompressedInputStream.new_ codec raw (CArray.start gerr__) in
    let gerr__ = CArray.get gerr__ 0 in
    if not (Ctypes.is_null gerr__)
    then begin
      let msg = getf (!@ gerr__) C.GError.message in
      if Ctypes.is_null msg
      then failwith "failed with null error message";
      let msg = C.strdup msg in
      C.GError.free gerr__;
      failwith msg
    end;
    if Ctypes.is_null res
    then failwith "returned null";
    Gc.finalise C.object_unref res;
    res

end

module CompressedOutputStream = struct
  type t = [ `compressed_output_stream | `output_stream ] gobject
  let of_gobject g =
    if C.CompressedOutputStream.get_type () = C.gobject_type g
    then Some g else None

  let new_ codec raw =
    let gerr__ = CArray.make (ptr C.GError.t) 1 in
    let res = C.CompressedOutputStream.new_ codec raw (CArray.start gerr__) in
    let gerr__ = CArray.get gerr__ 0 in
    if not (Ctypes.is_null gerr__)
    then begin
      let msg = getf (!@ gerr__) C.GError.message in
      if Ctypes.is_null msg
      then failwith "failed with null error message";
      let msg = C.strdup msg in
      C.GError.free gerr__;
      failwith msg
    end;
    if Ctypes.is_null res
    then failwith "returned null";
    Gc.finalise C.object_unref res;
    res

end

module CountOptions = struct
  type t = [ `count_options ] gobject
  let of_gobject g =
    if C.CountOptions.get_type () = C.gobject_type g
    then Some g else None

  let new_ () =
    let res = C.CountOptions.new_ () in
    if Ctypes.is_null res
    then failwith "returned null";
    Gc.finalise C.object_unref res;
    res

end

module DataType = struct
  type t = [ `data_type ] gobject
  let of_gobject g =
    if C.DataType.get_type () = C.gobject_type g
    then Some g else None

  let equal t__ other_data_type =
    let res = C.DataType.equal t__ other_data_type in
    res

  let to_string t__ =
    let res = C.DataType.to_string t__ in
    res

end

module Date32Array = struct
  type t = [ `date32_array | `numeric_array | `primitive_array | `array_ ] gobject
  let of_gobject g =
    if C.Date32Array.get_type () = C.gobject_type g
    then Some g else None

  let new_ ?null_bitmap length data n_nulls =
    let res = C.Date32Array.new_ length data (match null_bitmap with | None -> null | Some v -> v) n_nulls in
    if Ctypes.is_null res
    then failwith "returned null";
    Gc.finalise C.object_unref res;
    res

  let get_value t__ i =
    let res = C.Date32Array.get_value t__ i in
    res

end

module Date32ArrayBuilder = struct
  type t = [ `date32_array_builder | `array_builder ] gobject
  let of_gobject g =
    if C.Date32ArrayBuilder.get_type () = C.gobject_type g
    then Some g else None

  let new_ () =
    let res = C.Date32ArrayBuilder.new_ () in
    if Ctypes.is_null res
    then failwith "returned null";
    Gc.finalise C.object_unref res;
    res

  let append_null t__ =
    let gerr__ = CArray.make (ptr C.GError.t) 1 in
    let res = C.Date32ArrayBuilder.append_null t__ (CArray.start gerr__) in
    let gerr__ = CArray.get gerr__ 0 in
    if not (Ctypes.is_null gerr__)
    then begin
      let msg = getf (!@ gerr__) C.GError.message in
      if Ctypes.is_null msg
      then failwith "failed with null error message";
      let msg = C.strdup msg in
      C.GError.free gerr__;
      failwith msg
    end;
    res

  let append_nulls t__ n =
    let gerr__ = CArray.make (ptr C.GError.t) 1 in
    let res = C.Date32ArrayBuilder.append_nulls t__ n (CArray.start gerr__) in
    let gerr__ = CArray.get gerr__ 0 in
    if not (Ctypes.is_null gerr__)
    then begin
      let msg = getf (!@ gerr__) C.GError.message in
      if Ctypes.is_null msg
      then failwith "failed with null error message";
      let msg = C.strdup msg in
      C.GError.free gerr__;
      failwith msg
    end;
    res

  let append_value t__ value =
    let gerr__ = CArray.make (ptr C.GError.t) 1 in
    let res = C.Date32ArrayBuilder.append_value t__ value (CArray.start gerr__) in
    let gerr__ = CArray.get gerr__ 0 in
    if not (Ctypes.is_null gerr__)
    then begin
      let msg = getf (!@ gerr__) C.GError.message in
      if Ctypes.is_null msg
      then failwith "failed with null error message";
      let msg = C.strdup msg in
      C.GError.free gerr__;
      failwith msg
    end;
    res

end

module Date32DataType = struct
  type t = [ `date32_data_type | `data_type ] gobject
  let of_gobject g =
    if C.Date32DataType.get_type () = C.gobject_type g
    then Some g else None

  let new_ () =
    let res = C.Date32DataType.new_ () in
    if Ctypes.is_null res
    then failwith "returned null";
    Gc.finalise C.object_unref res;
    res

end

module Date64Array = struct
  type t = [ `date64_array | `numeric_array | `primitive_array | `array_ ] gobject
  let of_gobject g =
    if C.Date64Array.get_type () = C.gobject_type g
    then Some g else None

  let new_ ?null_bitmap length data n_nulls =
    let res = C.Date64Array.new_ length data (match null_bitmap with | None -> null | Some v -> v) n_nulls in
    if Ctypes.is_null res
    then failwith "returned null";
    Gc.finalise C.object_unref res;
    res

  let get_value t__ i =
    let res = C.Date64Array.get_value t__ i in
    res

end

module Date64ArrayBuilder = struct
  type t = [ `date64_array_builder | `array_builder ] gobject
  let of_gobject g =
    if C.Date64ArrayBuilder.get_type () = C.gobject_type g
    then Some g else None

  let new_ () =
    let res = C.Date64ArrayBuilder.new_ () in
    if Ctypes.is_null res
    then failwith "returned null";
    Gc.finalise C.object_unref res;
    res

  let append_null t__ =
    let gerr__ = CArray.make (ptr C.GError.t) 1 in
    let res = C.Date64ArrayBuilder.append_null t__ (CArray.start gerr__) in
    let gerr__ = CArray.get gerr__ 0 in
    if not (Ctypes.is_null gerr__)
    then begin
      let msg = getf (!@ gerr__) C.GError.message in
      if Ctypes.is_null msg
      then failwith "failed with null error message";
      let msg = C.strdup msg in
      C.GError.free gerr__;
      failwith msg
    end;
    res

  let append_nulls t__ n =
    let gerr__ = CArray.make (ptr C.GError.t) 1 in
    let res = C.Date64ArrayBuilder.append_nulls t__ n (CArray.start gerr__) in
    let gerr__ = CArray.get gerr__ 0 in
    if not (Ctypes.is_null gerr__)
    then begin
      let msg = getf (!@ gerr__) C.GError.message in
      if Ctypes.is_null msg
      then failwith "failed with null error message";
      let msg = C.strdup msg in
      C.GError.free gerr__;
      failwith msg
    end;
    res

  let append_value t__ value =
    let gerr__ = CArray.make (ptr C.GError.t) 1 in
    let res = C.Date64ArrayBuilder.append_value t__ value (CArray.start gerr__) in
    let gerr__ = CArray.get gerr__ 0 in
    if not (Ctypes.is_null gerr__)
    then begin
      let msg = getf (!@ gerr__) C.GError.message in
      if Ctypes.is_null msg
      then failwith "failed with null error message";
      let msg = C.strdup msg in
      C.GError.free gerr__;
      failwith msg
    end;
    res

end

module Date64DataType = struct
  type t = [ `date64_data_type | `data_type ] gobject
  let of_gobject g =
    if C.Date64DataType.get_type () = C.gobject_type g
    then Some g else None

  let new_ () =
    let res = C.Date64DataType.new_ () in
    if Ctypes.is_null res
    then failwith "returned null";
    Gc.finalise C.object_unref res;
    res

end

module Decimal128 = struct
  type t = [ `decimal128 ] gobject
  let of_gobject g =
    if C.Decimal128.get_type () = C.gobject_type g
    then Some g else None

  let new_integer data =
    let res = C.Decimal128.new_integer data in
    if Ctypes.is_null res
    then failwith "returned null";
    Gc.finalise C.object_unref res;
    res

  let new_string data =
    let res = C.Decimal128.new_string data in
    if Ctypes.is_null res
    then failwith "returned null";
    Gc.finalise C.object_unref res;
    res

  let divide ?remainder t__ right =
    let gerr__ = CArray.make (ptr C.GError.t) 1 in
    let res = C.Decimal128.divide t__ right (match remainder with | None -> null | Some v -> v) (CArray.start gerr__) in
    let gerr__ = CArray.get gerr__ 0 in
    if not (Ctypes.is_null gerr__)
    then begin
      let msg = getf (!@ gerr__) C.GError.message in
      if Ctypes.is_null msg
      then failwith "failed with null error message";
      let msg = C.strdup msg in
      C.GError.free gerr__;
      failwith msg
    end;
    if Ctypes.is_null res
    then failwith "returned null";
    Gc.finalise C.object_unref res;
    res

  let equal t__ other_decimal =
    let res = C.Decimal128.equal t__ other_decimal in
    res

  let greater_than t__ other_decimal =
    let res = C.Decimal128.greater_than t__ other_decimal in
    res

  let greater_than_or_equal t__ other_decimal =
    let res = C.Decimal128.greater_than_or_equal t__ other_decimal in
    res

  let less_than t__ other_decimal =
    let res = C.Decimal128.less_than t__ other_decimal in
    res

  let less_than_or_equal t__ other_decimal =
    let res = C.Decimal128.less_than_or_equal t__ other_decimal in
    res

  let minus t__ right =
    let res = C.Decimal128.minus t__ right in
    if Ctypes.is_null res
    then failwith "returned null";
    Gc.finalise C.object_unref res;
    res

  let multiply t__ right =
    let res = C.Decimal128.multiply t__ right in
    if Ctypes.is_null res
    then failwith "returned null";
    Gc.finalise C.object_unref res;
    res

  let not_equal t__ other_decimal =
    let res = C.Decimal128.not_equal t__ other_decimal in
    res

  let plus t__ right =
    let res = C.Decimal128.plus t__ right in
    if Ctypes.is_null res
    then failwith "returned null";
    Gc.finalise C.object_unref res;
    res

  let to_integer t__ =
    let res = C.Decimal128.to_integer t__ in
    res

  let to_string t__ =
    let res = C.Decimal128.to_string t__ in
    res

  let to_string_scale t__ scale =
    let res = C.Decimal128.to_string_scale t__ scale in
    res

end

module Decimal128Array = struct
  type t = [ `decimal128_array | `fixed_size_binary_array | `primitive_array | `array_ ] gobject
  let of_gobject g =
    if C.Decimal128Array.get_type () = C.gobject_type g
    then Some g else None

  let format_value t__ i =
    let res = C.Decimal128Array.format_value t__ i in
    res

  let get_value t__ i =
    let res = C.Decimal128Array.get_value t__ i in
    if Ctypes.is_null res
    then failwith "returned null";
    Gc.finalise C.object_unref res;
    res

end

module Decimal128ArrayBuilder = struct
  type t = [ `decimal128_array_builder | `array_builder ] gobject
  let of_gobject g =
    if C.Decimal128ArrayBuilder.get_type () = C.gobject_type g
    then Some g else None

  let new_ data_type =
    let res = C.Decimal128ArrayBuilder.new_ data_type in
    if Ctypes.is_null res
    then failwith "returned null";
    Gc.finalise C.object_unref res;
    res

  let append_null t__ =
    let gerr__ = CArray.make (ptr C.GError.t) 1 in
    let res = C.Decimal128ArrayBuilder.append_null t__ (CArray.start gerr__) in
    let gerr__ = CArray.get gerr__ 0 in
    if not (Ctypes.is_null gerr__)
    then begin
      let msg = getf (!@ gerr__) C.GError.message in
      if Ctypes.is_null msg
      then failwith "failed with null error message";
      let msg = C.strdup msg in
      C.GError.free gerr__;
      failwith msg
    end;
    res

  let append_value t__ value =
    let gerr__ = CArray.make (ptr C.GError.t) 1 in
    let res = C.Decimal128ArrayBuilder.append_value t__ value (CArray.start gerr__) in
    let gerr__ = CArray.get gerr__ 0 in
    if not (Ctypes.is_null gerr__)
    then begin
      let msg = getf (!@ gerr__) C.GError.message in
      if Ctypes.is_null msg
      then failwith "failed with null error message";
      let msg = C.strdup msg in
      C.GError.free gerr__;
      failwith msg
    end;
    res

end

module Decimal128DataType = struct
  type t = [ `decimal128_data_type | `decimal_data_type | `fixed_size_binary_data_type | `fixed_width_data_type | `data_type ] gobject
  let of_gobject g =
    if C.Decimal128DataType.get_type () = C.gobject_type g
    then Some g else None

  let new_ precision scale =
    let res = C.Decimal128DataType.new_ precision scale in
    if Ctypes.is_null res
    then failwith "returned null";
    Gc.finalise C.object_unref res;
    res

end

module DecimalDataType = struct
  type t = [ `decimal_data_type | `fixed_size_binary_data_type | `fixed_width_data_type | `data_type ] gobject
  let of_gobject g =
    if C.DecimalDataType.get_type () = C.gobject_type g
    then Some g else None

  let get_precision t__ =
    let res = C.DecimalDataType.get_precision t__ in
    res

  let get_scale t__ =
    let res = C.DecimalDataType.get_scale t__ in
    res

end

module DenseUnionArray = struct
  type t = [ `dense_union_array | `union_array | `array_ ] gobject
  let of_gobject g =
    if C.DenseUnionArray.get_type () = C.gobject_type g
    then Some g else None

end

module DenseUnionDataType = struct
  type t = [ `dense_union_data_type | `union_data_type | `data_type ] gobject
  let of_gobject g =
    if C.DenseUnionDataType.get_type () = C.gobject_type g
    then Some g else None

end

module DictionaryArray = struct
  type t = [ `dictionary_array | `array_ ] gobject
  let of_gobject g =
    if C.DictionaryArray.get_type () = C.gobject_type g
    then Some g else None

  let new_ data_type indices =
    let res = C.DictionaryArray.new_ data_type indices in
    if Ctypes.is_null res
    then failwith "returned null";
    Gc.finalise C.object_unref res;
    res

  let get_dictionary t__ =
    let res = C.DictionaryArray.get_dictionary t__ in
    if Ctypes.is_null res
    then failwith "returned null";
    Gc.finalise C.object_unref res;
    res

  let get_dictionary_data_type t__ =
    let res = C.DictionaryArray.get_dictionary_data_type t__ in
    if Ctypes.is_null res
    then failwith "returned null";
    Gc.finalise C.object_unref res;
    res

  let get_indices t__ =
    let res = C.DictionaryArray.get_indices t__ in
    if Ctypes.is_null res
    then failwith "returned null";
    Gc.finalise C.object_unref res;
    res

end

module DictionaryDataType = struct
  type t = [ `dictionary_data_type | `fixed_width_data_type | `data_type ] gobject
  let of_gobject g =
    if C.DictionaryDataType.get_type () = C.gobject_type g
    then Some g else None

  let new_ index_data_type dictionary ordered =
    let res = C.DictionaryDataType.new_ index_data_type dictionary ordered in
    if Ctypes.is_null res
    then failwith "returned null";
    Gc.finalise C.object_unref res;
    res

  let get_dictionary t__ =
    let res = C.DictionaryDataType.get_dictionary t__ in
    if Ctypes.is_null res
    then failwith "returned null";
    Gc.finalise C.object_unref res;
    res

  let get_index_data_type t__ =
    let res = C.DictionaryDataType.get_index_data_type t__ in
    if Ctypes.is_null res
    then failwith "returned null";
    Gc.finalise C.object_unref res;
    res

  let is_ordered t__ =
    let res = C.DictionaryDataType.is_ordered t__ in
    res

end

module DoubleArray = struct
  type t = [ `double_array | `numeric_array | `primitive_array | `array_ ] gobject
  let of_gobject g =
    if C.DoubleArray.get_type () = C.gobject_type g
    then Some g else None

  let new_ ?null_bitmap length data n_nulls =
    let res = C.DoubleArray.new_ length data (match null_bitmap with | None -> null | Some v -> v) n_nulls in
    if Ctypes.is_null res
    then failwith "returned null";
    Gc.finalise C.object_unref res;
    res

  let get_value t__ i =
    let res = C.DoubleArray.get_value t__ i in
    res

  let sum t__ =
    let gerr__ = CArray.make (ptr C.GError.t) 1 in
    let res = C.DoubleArray.sum t__ (CArray.start gerr__) in
    let gerr__ = CArray.get gerr__ 0 in
    if not (Ctypes.is_null gerr__)
    then begin
      let msg = getf (!@ gerr__) C.GError.message in
      if Ctypes.is_null msg
      then failwith "failed with null error message";
      let msg = C.strdup msg in
      C.GError.free gerr__;
      failwith msg
    end;
    res

end

module DoubleArrayBuilder = struct
  type t = [ `double_array_builder | `array_builder ] gobject
  let of_gobject g =
    if C.DoubleArrayBuilder.get_type () = C.gobject_type g
    then Some g else None

  let new_ () =
    let res = C.DoubleArrayBuilder.new_ () in
    if Ctypes.is_null res
    then failwith "returned null";
    Gc.finalise C.object_unref res;
    res

  let append_null t__ =
    let gerr__ = CArray.make (ptr C.GError.t) 1 in
    let res = C.DoubleArrayBuilder.append_null t__ (CArray.start gerr__) in
    let gerr__ = CArray.get gerr__ 0 in
    if not (Ctypes.is_null gerr__)
    then begin
      let msg = getf (!@ gerr__) C.GError.message in
      if Ctypes.is_null msg
      then failwith "failed with null error message";
      let msg = C.strdup msg in
      C.GError.free gerr__;
      failwith msg
    end;
    res

  let append_nulls t__ n =
    let gerr__ = CArray.make (ptr C.GError.t) 1 in
    let res = C.DoubleArrayBuilder.append_nulls t__ n (CArray.start gerr__) in
    let gerr__ = CArray.get gerr__ 0 in
    if not (Ctypes.is_null gerr__)
    then begin
      let msg = getf (!@ gerr__) C.GError.message in
      if Ctypes.is_null msg
      then failwith "failed with null error message";
      let msg = C.strdup msg in
      C.GError.free gerr__;
      failwith msg
    end;
    res

  let append_value t__ value =
    let gerr__ = CArray.make (ptr C.GError.t) 1 in
    let res = C.DoubleArrayBuilder.append_value t__ value (CArray.start gerr__) in
    let gerr__ = CArray.get gerr__ 0 in
    if not (Ctypes.is_null gerr__)
    then begin
      let msg = getf (!@ gerr__) C.GError.message in
      if Ctypes.is_null msg
      then failwith "failed with null error message";
      let msg = C.strdup msg in
      C.GError.free gerr__;
      failwith msg
    end;
    res

end

module DoubleDataType = struct
  type t = [ `double_data_type | `floating_point_data_type | `numeric_data_type | `fixed_width_data_type | `data_type ] gobject
  let of_gobject g =
    if C.DoubleDataType.get_type () = C.gobject_type g
    then Some g else None

  let new_ () =
    let res = C.DoubleDataType.new_ () in
    if Ctypes.is_null res
    then failwith "returned null";
    Gc.finalise C.object_unref res;
    res

end

module FeatherFileReader = struct
  type t = [ `feather_file_reader ] gobject
  let of_gobject g =
    if C.FeatherFileReader.get_type () = C.gobject_type g
    then Some g else None

  let new_ file =
    let gerr__ = CArray.make (ptr C.GError.t) 1 in
    let res = C.FeatherFileReader.new_ file (CArray.start gerr__) in
    let gerr__ = CArray.get gerr__ 0 in
    if not (Ctypes.is_null gerr__)
    then begin
      let msg = getf (!@ gerr__) C.GError.message in
      if Ctypes.is_null msg
      then failwith "failed with null error message";
      let msg = C.strdup msg in
      C.GError.free gerr__;
      failwith msg
    end;
    if Ctypes.is_null res
    then failwith "returned null";
    Gc.finalise C.object_unref res;
    res

  let get_column t__ i =
    let gerr__ = CArray.make (ptr C.GError.t) 1 in
    let res = C.FeatherFileReader.get_column t__ i (CArray.start gerr__) in
    let gerr__ = CArray.get gerr__ 0 in
    if not (Ctypes.is_null gerr__)
    then begin
      let msg = getf (!@ gerr__) C.GError.message in
      if Ctypes.is_null msg
      then failwith "failed with null error message";
      let msg = C.strdup msg in
      C.GError.free gerr__;
      failwith msg
    end;
    if Ctypes.is_null res
    then failwith "returned null";
    Gc.finalise C.object_unref res;
    res

  let get_column_name t__ i =
    let res = C.FeatherFileReader.get_column_name t__ i in
    res

  let get_description t__ =
    let res = C.FeatherFileReader.get_description t__ in
    res

  let get_n_columns t__ =
    let res = C.FeatherFileReader.get_n_columns t__ in
    res

  let get_n_rows t__ =
    let res = C.FeatherFileReader.get_n_rows t__ in
    res

  let get_version t__ =
    let res = C.FeatherFileReader.get_version t__ in
    res

  let has_description t__ =
    let res = C.FeatherFileReader.has_description t__ in
    res

  let read t__ =
    let gerr__ = CArray.make (ptr C.GError.t) 1 in
    let res = C.FeatherFileReader.read t__ (CArray.start gerr__) in
    let gerr__ = CArray.get gerr__ 0 in
    if not (Ctypes.is_null gerr__)
    then begin
      let msg = getf (!@ gerr__) C.GError.message in
      if Ctypes.is_null msg
      then failwith "failed with null error message";
      let msg = C.strdup msg in
      C.GError.free gerr__;
      failwith msg
    end;
    if Ctypes.is_null res
    then failwith "returned null";
    Gc.finalise C.object_unref res;
    res

end

module FeatherFileWriter = struct
  type t = [ `feather_file_writer ] gobject
  let of_gobject g =
    if C.FeatherFileWriter.get_type () = C.gobject_type g
    then Some g else None

  let new_ sink =
    let gerr__ = CArray.make (ptr C.GError.t) 1 in
    let res = C.FeatherFileWriter.new_ sink (CArray.start gerr__) in
    let gerr__ = CArray.get gerr__ 0 in
    if not (Ctypes.is_null gerr__)
    then begin
      let msg = getf (!@ gerr__) C.GError.message in
      if Ctypes.is_null msg
      then failwith "failed with null error message";
      let msg = C.strdup msg in
      C.GError.free gerr__;
      failwith msg
    end;
    if Ctypes.is_null res
    then failwith "returned null";
    Gc.finalise C.object_unref res;
    res

  let append t__ name array =
    let gerr__ = CArray.make (ptr C.GError.t) 1 in
    let res = C.FeatherFileWriter.append t__ name array (CArray.start gerr__) in
    let gerr__ = CArray.get gerr__ 0 in
    if not (Ctypes.is_null gerr__)
    then begin
      let msg = getf (!@ gerr__) C.GError.message in
      if Ctypes.is_null msg
      then failwith "failed with null error message";
      let msg = C.strdup msg in
      C.GError.free gerr__;
      failwith msg
    end;
    res

  let close t__ =
    let gerr__ = CArray.make (ptr C.GError.t) 1 in
    let res = C.FeatherFileWriter.close t__ (CArray.start gerr__) in
    let gerr__ = CArray.get gerr__ 0 in
    if not (Ctypes.is_null gerr__)
    then begin
      let msg = getf (!@ gerr__) C.GError.message in
      if Ctypes.is_null msg
      then failwith "failed with null error message";
      let msg = C.strdup msg in
      C.GError.free gerr__;
      failwith msg
    end;
    res

  let write t__ table =
    let gerr__ = CArray.make (ptr C.GError.t) 1 in
    let res = C.FeatherFileWriter.write t__ table (CArray.start gerr__) in
    let gerr__ = CArray.get gerr__ 0 in
    if not (Ctypes.is_null gerr__)
    then begin
      let msg = getf (!@ gerr__) C.GError.message in
      if Ctypes.is_null msg
      then failwith "failed with null error message";
      let msg = C.strdup msg in
      C.GError.free gerr__;
      failwith msg
    end;
    res

end

module Field = struct
  type t = [ `field ] gobject
  let of_gobject g =
    if C.Field.get_type () = C.gobject_type g
    then Some g else None

  let new_ name data_type =
    let res = C.Field.new_ name data_type in
    if Ctypes.is_null res
    then failwith "returned null";
    Gc.finalise C.object_unref res;
    res

  let new_full name data_type nullable =
    let res = C.Field.new_full name data_type nullable in
    if Ctypes.is_null res
    then failwith "returned null";
    Gc.finalise C.object_unref res;
    res

  let equal t__ other_field =
    let res = C.Field.equal t__ other_field in
    res

  let get_data_type t__ =
    let res = C.Field.get_data_type t__ in
    if Ctypes.is_null res
    then failwith "returned null";
    Gc.finalise C.object_unref res;
    res

  let get_name t__ =
    let res = C.Field.get_name t__ in
    res

  let is_nullable t__ =
    let res = C.Field.is_nullable t__ in
    res

  let to_string t__ =
    let res = C.Field.to_string t__ in
    res

end

module FileOutputStream = struct
  type t = [ `file_output_stream | `output_stream ] gobject
  let of_gobject g =
    if C.FileOutputStream.get_type () = C.gobject_type g
    then Some g else None

  let new_ path append =
    let gerr__ = CArray.make (ptr C.GError.t) 1 in
    let res = C.FileOutputStream.new_ path append (CArray.start gerr__) in
    let gerr__ = CArray.get gerr__ 0 in
    if not (Ctypes.is_null gerr__)
    then begin
      let msg = getf (!@ gerr__) C.GError.message in
      if Ctypes.is_null msg
      then failwith "failed with null error message";
      let msg = C.strdup msg in
      C.GError.free gerr__;
      failwith msg
    end;
    if Ctypes.is_null res
    then failwith "returned null";
    Gc.finalise C.object_unref res;
    res

end

module FixedSizeBinaryArray = struct
  type t = [ `fixed_size_binary_array | `primitive_array | `array_ ] gobject
  let of_gobject g =
    if C.FixedSizeBinaryArray.get_type () = C.gobject_type g
    then Some g else None

end

module FixedSizeBinaryDataType = struct
  type t = [ `fixed_size_binary_data_type | `fixed_width_data_type | `data_type ] gobject
  let of_gobject g =
    if C.FixedSizeBinaryDataType.get_type () = C.gobject_type g
    then Some g else None

  let new_ byte_width =
    let res = C.FixedSizeBinaryDataType.new_ byte_width in
    if Ctypes.is_null res
    then failwith "returned null";
    Gc.finalise C.object_unref res;
    res

  let get_byte_width t__ =
    let res = C.FixedSizeBinaryDataType.get_byte_width t__ in
    res

end

module FixedWidthDataType = struct
  type t = [ `fixed_width_data_type | `data_type ] gobject
  let of_gobject g =
    if C.FixedWidthDataType.get_type () = C.gobject_type g
    then Some g else None

  let get_bit_width t__ =
    let res = C.FixedWidthDataType.get_bit_width t__ in
    res

end

module FloatArray = struct
  type t = [ `float_array | `numeric_array | `primitive_array | `array_ ] gobject
  let of_gobject g =
    if C.FloatArray.get_type () = C.gobject_type g
    then Some g else None

  let new_ ?null_bitmap length data n_nulls =
    let res = C.FloatArray.new_ length data (match null_bitmap with | None -> null | Some v -> v) n_nulls in
    if Ctypes.is_null res
    then failwith "returned null";
    Gc.finalise C.object_unref res;
    res

  let get_value t__ i =
    let res = C.FloatArray.get_value t__ i in
    res

  let sum t__ =
    let gerr__ = CArray.make (ptr C.GError.t) 1 in
    let res = C.FloatArray.sum t__ (CArray.start gerr__) in
    let gerr__ = CArray.get gerr__ 0 in
    if not (Ctypes.is_null gerr__)
    then begin
      let msg = getf (!@ gerr__) C.GError.message in
      if Ctypes.is_null msg
      then failwith "failed with null error message";
      let msg = C.strdup msg in
      C.GError.free gerr__;
      failwith msg
    end;
    res

end

module FloatArrayBuilder = struct
  type t = [ `float_array_builder | `array_builder ] gobject
  let of_gobject g =
    if C.FloatArrayBuilder.get_type () = C.gobject_type g
    then Some g else None

  let new_ () =
    let res = C.FloatArrayBuilder.new_ () in
    if Ctypes.is_null res
    then failwith "returned null";
    Gc.finalise C.object_unref res;
    res

  let append_null t__ =
    let gerr__ = CArray.make (ptr C.GError.t) 1 in
    let res = C.FloatArrayBuilder.append_null t__ (CArray.start gerr__) in
    let gerr__ = CArray.get gerr__ 0 in
    if not (Ctypes.is_null gerr__)
    then begin
      let msg = getf (!@ gerr__) C.GError.message in
      if Ctypes.is_null msg
      then failwith "failed with null error message";
      let msg = C.strdup msg in
      C.GError.free gerr__;
      failwith msg
    end;
    res

  let append_nulls t__ n =
    let gerr__ = CArray.make (ptr C.GError.t) 1 in
    let res = C.FloatArrayBuilder.append_nulls t__ n (CArray.start gerr__) in
    let gerr__ = CArray.get gerr__ 0 in
    if not (Ctypes.is_null gerr__)
    then begin
      let msg = getf (!@ gerr__) C.GError.message in
      if Ctypes.is_null msg
      then failwith "failed with null error message";
      let msg = C.strdup msg in
      C.GError.free gerr__;
      failwith msg
    end;
    res

  let append_value t__ value =
    let gerr__ = CArray.make (ptr C.GError.t) 1 in
    let res = C.FloatArrayBuilder.append_value t__ value (CArray.start gerr__) in
    let gerr__ = CArray.get gerr__ 0 in
    if not (Ctypes.is_null gerr__)
    then begin
      let msg = getf (!@ gerr__) C.GError.message in
      if Ctypes.is_null msg
      then failwith "failed with null error message";
      let msg = C.strdup msg in
      C.GError.free gerr__;
      failwith msg
    end;
    res

end

module FloatDataType = struct
  type t = [ `float_data_type | `floating_point_data_type | `numeric_data_type | `fixed_width_data_type | `data_type ] gobject
  let of_gobject g =
    if C.FloatDataType.get_type () = C.gobject_type g
    then Some g else None

  let new_ () =
    let res = C.FloatDataType.new_ () in
    if Ctypes.is_null res
    then failwith "returned null";
    Gc.finalise C.object_unref res;
    res

end

module FloatingPointDataType = struct
  type t = [ `floating_point_data_type | `numeric_data_type | `fixed_width_data_type | `data_type ] gobject
  let of_gobject g =
    if C.FloatingPointDataType.get_type () = C.gobject_type g
    then Some g else None

end

module GIOInputStream = struct
  type t = [ `gio_input_stream | `seekable_input_stream | `input_stream ] gobject
  let of_gobject g =
    if C.GIOInputStream.get_type () = C.gobject_type g
    then Some g else None

  let new_ gio_input_stream =
    let res = C.GIOInputStream.new_ gio_input_stream in
    if Ctypes.is_null res
    then failwith "returned null";
    Gc.finalise C.object_unref res;
    res

end

module GIOOutputStream = struct
  type t = [ `gio_output_stream | `output_stream ] gobject
  let of_gobject g =
    if C.GIOOutputStream.get_type () = C.gobject_type g
    then Some g else None

  let new_ gio_output_stream =
    let res = C.GIOOutputStream.new_ gio_output_stream in
    if Ctypes.is_null res
    then failwith "returned null";
    Gc.finalise C.object_unref res;
    res

end

module InputStream = struct
  type t = [ `input_stream ] gobject
  let of_gobject g =
    if C.InputStream.get_type () = C.gobject_type g
    then Some g else None

  let advance t__ n_bytes =
    let gerr__ = CArray.make (ptr C.GError.t) 1 in
    let res = C.InputStream.advance t__ n_bytes (CArray.start gerr__) in
    let gerr__ = CArray.get gerr__ 0 in
    if not (Ctypes.is_null gerr__)
    then begin
      let msg = getf (!@ gerr__) C.GError.message in
      if Ctypes.is_null msg
      then failwith "failed with null error message";
      let msg = C.strdup msg in
      C.GError.free gerr__;
      failwith msg
    end;
    res

  let align t__ alignment =
    let gerr__ = CArray.make (ptr C.GError.t) 1 in
    let res = C.InputStream.align t__ alignment (CArray.start gerr__) in
    let gerr__ = CArray.get gerr__ 0 in
    if not (Ctypes.is_null gerr__)
    then begin
      let msg = getf (!@ gerr__) C.GError.message in
      if Ctypes.is_null msg
      then failwith "failed with null error message";
      let msg = C.strdup msg in
      C.GError.free gerr__;
      failwith msg
    end;
    res

  let read_tensor t__ =
    let gerr__ = CArray.make (ptr C.GError.t) 1 in
    let res = C.InputStream.read_tensor t__ (CArray.start gerr__) in
    let gerr__ = CArray.get gerr__ 0 in
    if not (Ctypes.is_null gerr__)
    then begin
      let msg = getf (!@ gerr__) C.GError.message in
      if Ctypes.is_null msg
      then failwith "failed with null error message";
      let msg = C.strdup msg in
      C.GError.free gerr__;
      failwith msg
    end;
    if Ctypes.is_null res
    then failwith "returned null";
    Gc.finalise C.object_unref res;
    res

end

module Int16Array = struct
  type t = [ `int16_array | `numeric_array | `primitive_array | `array_ ] gobject
  let of_gobject g =
    if C.Int16Array.get_type () = C.gobject_type g
    then Some g else None

  let new_ ?null_bitmap length data n_nulls =
    let res = C.Int16Array.new_ length data (match null_bitmap with | None -> null | Some v -> v) n_nulls in
    if Ctypes.is_null res
    then failwith "returned null";
    Gc.finalise C.object_unref res;
    res

  let get_value t__ i =
    let res = C.Int16Array.get_value t__ i in
    res

  let sum t__ =
    let gerr__ = CArray.make (ptr C.GError.t) 1 in
    let res = C.Int16Array.sum t__ (CArray.start gerr__) in
    let gerr__ = CArray.get gerr__ 0 in
    if not (Ctypes.is_null gerr__)
    then begin
      let msg = getf (!@ gerr__) C.GError.message in
      if Ctypes.is_null msg
      then failwith "failed with null error message";
      let msg = C.strdup msg in
      C.GError.free gerr__;
      failwith msg
    end;
    res

end

module Int16ArrayBuilder = struct
  type t = [ `int16_array_builder | `array_builder ] gobject
  let of_gobject g =
    if C.Int16ArrayBuilder.get_type () = C.gobject_type g
    then Some g else None

  let new_ () =
    let res = C.Int16ArrayBuilder.new_ () in
    if Ctypes.is_null res
    then failwith "returned null";
    Gc.finalise C.object_unref res;
    res

  let append_null t__ =
    let gerr__ = CArray.make (ptr C.GError.t) 1 in
    let res = C.Int16ArrayBuilder.append_null t__ (CArray.start gerr__) in
    let gerr__ = CArray.get gerr__ 0 in
    if not (Ctypes.is_null gerr__)
    then begin
      let msg = getf (!@ gerr__) C.GError.message in
      if Ctypes.is_null msg
      then failwith "failed with null error message";
      let msg = C.strdup msg in
      C.GError.free gerr__;
      failwith msg
    end;
    res

  let append_nulls t__ n =
    let gerr__ = CArray.make (ptr C.GError.t) 1 in
    let res = C.Int16ArrayBuilder.append_nulls t__ n (CArray.start gerr__) in
    let gerr__ = CArray.get gerr__ 0 in
    if not (Ctypes.is_null gerr__)
    then begin
      let msg = getf (!@ gerr__) C.GError.message in
      if Ctypes.is_null msg
      then failwith "failed with null error message";
      let msg = C.strdup msg in
      C.GError.free gerr__;
      failwith msg
    end;
    res

  let append_value t__ value =
    let gerr__ = CArray.make (ptr C.GError.t) 1 in
    let res = C.Int16ArrayBuilder.append_value t__ value (CArray.start gerr__) in
    let gerr__ = CArray.get gerr__ 0 in
    if not (Ctypes.is_null gerr__)
    then begin
      let msg = getf (!@ gerr__) C.GError.message in
      if Ctypes.is_null msg
      then failwith "failed with null error message";
      let msg = C.strdup msg in
      C.GError.free gerr__;
      failwith msg
    end;
    res

end

module Int16DataType = struct
  type t = [ `int16_data_type | `integer_data_type | `numeric_data_type | `fixed_width_data_type | `data_type ] gobject
  let of_gobject g =
    if C.Int16DataType.get_type () = C.gobject_type g
    then Some g else None

  let new_ () =
    let res = C.Int16DataType.new_ () in
    if Ctypes.is_null res
    then failwith "returned null";
    Gc.finalise C.object_unref res;
    res

end

module Int32Array = struct
  type t = [ `int32_array | `numeric_array | `primitive_array | `array_ ] gobject
  let of_gobject g =
    if C.Int32Array.get_type () = C.gobject_type g
    then Some g else None

  let new_ ?null_bitmap length data n_nulls =
    let res = C.Int32Array.new_ length data (match null_bitmap with | None -> null | Some v -> v) n_nulls in
    if Ctypes.is_null res
    then failwith "returned null";
    Gc.finalise C.object_unref res;
    res

  let get_value t__ i =
    let res = C.Int32Array.get_value t__ i in
    res

  let sum t__ =
    let gerr__ = CArray.make (ptr C.GError.t) 1 in
    let res = C.Int32Array.sum t__ (CArray.start gerr__) in
    let gerr__ = CArray.get gerr__ 0 in
    if not (Ctypes.is_null gerr__)
    then begin
      let msg = getf (!@ gerr__) C.GError.message in
      if Ctypes.is_null msg
      then failwith "failed with null error message";
      let msg = C.strdup msg in
      C.GError.free gerr__;
      failwith msg
    end;
    res

end

module Int32ArrayBuilder = struct
  type t = [ `int32_array_builder | `array_builder ] gobject
  let of_gobject g =
    if C.Int32ArrayBuilder.get_type () = C.gobject_type g
    then Some g else None

  let new_ () =
    let res = C.Int32ArrayBuilder.new_ () in
    if Ctypes.is_null res
    then failwith "returned null";
    Gc.finalise C.object_unref res;
    res

  let append_null t__ =
    let gerr__ = CArray.make (ptr C.GError.t) 1 in
    let res = C.Int32ArrayBuilder.append_null t__ (CArray.start gerr__) in
    let gerr__ = CArray.get gerr__ 0 in
    if not (Ctypes.is_null gerr__)
    then begin
      let msg = getf (!@ gerr__) C.GError.message in
      if Ctypes.is_null msg
      then failwith "failed with null error message";
      let msg = C.strdup msg in
      C.GError.free gerr__;
      failwith msg
    end;
    res

  let append_nulls t__ n =
    let gerr__ = CArray.make (ptr C.GError.t) 1 in
    let res = C.Int32ArrayBuilder.append_nulls t__ n (CArray.start gerr__) in
    let gerr__ = CArray.get gerr__ 0 in
    if not (Ctypes.is_null gerr__)
    then begin
      let msg = getf (!@ gerr__) C.GError.message in
      if Ctypes.is_null msg
      then failwith "failed with null error message";
      let msg = C.strdup msg in
      C.GError.free gerr__;
      failwith msg
    end;
    res

  let append_value t__ value =
    let gerr__ = CArray.make (ptr C.GError.t) 1 in
    let res = C.Int32ArrayBuilder.append_value t__ value (CArray.start gerr__) in
    let gerr__ = CArray.get gerr__ 0 in
    if not (Ctypes.is_null gerr__)
    then begin
      let msg = getf (!@ gerr__) C.GError.message in
      if Ctypes.is_null msg
      then failwith "failed with null error message";
      let msg = C.strdup msg in
      C.GError.free gerr__;
      failwith msg
    end;
    res

end

module Int32DataType = struct
  type t = [ `int32_data_type | `integer_data_type | `numeric_data_type | `fixed_width_data_type | `data_type ] gobject
  let of_gobject g =
    if C.Int32DataType.get_type () = C.gobject_type g
    then Some g else None

  let new_ () =
    let res = C.Int32DataType.new_ () in
    if Ctypes.is_null res
    then failwith "returned null";
    Gc.finalise C.object_unref res;
    res

end

module Int64Array = struct
  type t = [ `int64_array | `numeric_array | `primitive_array | `array_ ] gobject
  let of_gobject g =
    if C.Int64Array.get_type () = C.gobject_type g
    then Some g else None

  let new_ ?null_bitmap length data n_nulls =
    let res = C.Int64Array.new_ length data (match null_bitmap with | None -> null | Some v -> v) n_nulls in
    if Ctypes.is_null res
    then failwith "returned null";
    Gc.finalise C.object_unref res;
    res

  let get_value t__ i =
    let res = C.Int64Array.get_value t__ i in
    res

  let sum t__ =
    let gerr__ = CArray.make (ptr C.GError.t) 1 in
    let res = C.Int64Array.sum t__ (CArray.start gerr__) in
    let gerr__ = CArray.get gerr__ 0 in
    if not (Ctypes.is_null gerr__)
    then begin
      let msg = getf (!@ gerr__) C.GError.message in
      if Ctypes.is_null msg
      then failwith "failed with null error message";
      let msg = C.strdup msg in
      C.GError.free gerr__;
      failwith msg
    end;
    res

end

module Int64ArrayBuilder = struct
  type t = [ `int64_array_builder | `array_builder ] gobject
  let of_gobject g =
    if C.Int64ArrayBuilder.get_type () = C.gobject_type g
    then Some g else None

  let new_ () =
    let res = C.Int64ArrayBuilder.new_ () in
    if Ctypes.is_null res
    then failwith "returned null";
    Gc.finalise C.object_unref res;
    res

  let append_null t__ =
    let gerr__ = CArray.make (ptr C.GError.t) 1 in
    let res = C.Int64ArrayBuilder.append_null t__ (CArray.start gerr__) in
    let gerr__ = CArray.get gerr__ 0 in
    if not (Ctypes.is_null gerr__)
    then begin
      let msg = getf (!@ gerr__) C.GError.message in
      if Ctypes.is_null msg
      then failwith "failed with null error message";
      let msg = C.strdup msg in
      C.GError.free gerr__;
      failwith msg
    end;
    res

  let append_nulls t__ n =
    let gerr__ = CArray.make (ptr C.GError.t) 1 in
    let res = C.Int64ArrayBuilder.append_nulls t__ n (CArray.start gerr__) in
    let gerr__ = CArray.get gerr__ 0 in
    if not (Ctypes.is_null gerr__)
    then begin
      let msg = getf (!@ gerr__) C.GError.message in
      if Ctypes.is_null msg
      then failwith "failed with null error message";
      let msg = C.strdup msg in
      C.GError.free gerr__;
      failwith msg
    end;
    res

  let append_value t__ value =
    let gerr__ = CArray.make (ptr C.GError.t) 1 in
    let res = C.Int64ArrayBuilder.append_value t__ value (CArray.start gerr__) in
    let gerr__ = CArray.get gerr__ 0 in
    if not (Ctypes.is_null gerr__)
    then begin
      let msg = getf (!@ gerr__) C.GError.message in
      if Ctypes.is_null msg
      then failwith "failed with null error message";
      let msg = C.strdup msg in
      C.GError.free gerr__;
      failwith msg
    end;
    res

end

module Int64DataType = struct
  type t = [ `int64_data_type | `integer_data_type | `numeric_data_type | `fixed_width_data_type | `data_type ] gobject
  let of_gobject g =
    if C.Int64DataType.get_type () = C.gobject_type g
    then Some g else None

  let new_ () =
    let res = C.Int64DataType.new_ () in
    if Ctypes.is_null res
    then failwith "returned null";
    Gc.finalise C.object_unref res;
    res

end

module Int8Array = struct
  type t = [ `int8_array | `numeric_array | `primitive_array | `array_ ] gobject
  let of_gobject g =
    if C.Int8Array.get_type () = C.gobject_type g
    then Some g else None

  let new_ ?null_bitmap length data n_nulls =
    let res = C.Int8Array.new_ length data (match null_bitmap with | None -> null | Some v -> v) n_nulls in
    if Ctypes.is_null res
    then failwith "returned null";
    Gc.finalise C.object_unref res;
    res

  let get_value t__ i =
    let res = C.Int8Array.get_value t__ i in
    res

  let sum t__ =
    let gerr__ = CArray.make (ptr C.GError.t) 1 in
    let res = C.Int8Array.sum t__ (CArray.start gerr__) in
    let gerr__ = CArray.get gerr__ 0 in
    if not (Ctypes.is_null gerr__)
    then begin
      let msg = getf (!@ gerr__) C.GError.message in
      if Ctypes.is_null msg
      then failwith "failed with null error message";
      let msg = C.strdup msg in
      C.GError.free gerr__;
      failwith msg
    end;
    res

end

module Int8ArrayBuilder = struct
  type t = [ `int8_array_builder | `array_builder ] gobject
  let of_gobject g =
    if C.Int8ArrayBuilder.get_type () = C.gobject_type g
    then Some g else None

  let new_ () =
    let res = C.Int8ArrayBuilder.new_ () in
    if Ctypes.is_null res
    then failwith "returned null";
    Gc.finalise C.object_unref res;
    res

  let append_null t__ =
    let gerr__ = CArray.make (ptr C.GError.t) 1 in
    let res = C.Int8ArrayBuilder.append_null t__ (CArray.start gerr__) in
    let gerr__ = CArray.get gerr__ 0 in
    if not (Ctypes.is_null gerr__)
    then begin
      let msg = getf (!@ gerr__) C.GError.message in
      if Ctypes.is_null msg
      then failwith "failed with null error message";
      let msg = C.strdup msg in
      C.GError.free gerr__;
      failwith msg
    end;
    res

  let append_nulls t__ n =
    let gerr__ = CArray.make (ptr C.GError.t) 1 in
    let res = C.Int8ArrayBuilder.append_nulls t__ n (CArray.start gerr__) in
    let gerr__ = CArray.get gerr__ 0 in
    if not (Ctypes.is_null gerr__)
    then begin
      let msg = getf (!@ gerr__) C.GError.message in
      if Ctypes.is_null msg
      then failwith "failed with null error message";
      let msg = C.strdup msg in
      C.GError.free gerr__;
      failwith msg
    end;
    res

  let append_value t__ value =
    let gerr__ = CArray.make (ptr C.GError.t) 1 in
    let res = C.Int8ArrayBuilder.append_value t__ value (CArray.start gerr__) in
    let gerr__ = CArray.get gerr__ 0 in
    if not (Ctypes.is_null gerr__)
    then begin
      let msg = getf (!@ gerr__) C.GError.message in
      if Ctypes.is_null msg
      then failwith "failed with null error message";
      let msg = C.strdup msg in
      C.GError.free gerr__;
      failwith msg
    end;
    res

end

module Int8DataType = struct
  type t = [ `int8_data_type | `integer_data_type | `numeric_data_type | `fixed_width_data_type | `data_type ] gobject
  let of_gobject g =
    if C.Int8DataType.get_type () = C.gobject_type g
    then Some g else None

  let new_ () =
    let res = C.Int8DataType.new_ () in
    if Ctypes.is_null res
    then failwith "returned null";
    Gc.finalise C.object_unref res;
    res

end

module IntArrayBuilder = struct
  type t = [ `int_array_builder | `array_builder ] gobject
  let of_gobject g =
    if C.IntArrayBuilder.get_type () = C.gobject_type g
    then Some g else None

  let new_ () =
    let res = C.IntArrayBuilder.new_ () in
    if Ctypes.is_null res
    then failwith "returned null";
    Gc.finalise C.object_unref res;
    res

  let append_null t__ =
    let gerr__ = CArray.make (ptr C.GError.t) 1 in
    let res = C.IntArrayBuilder.append_null t__ (CArray.start gerr__) in
    let gerr__ = CArray.get gerr__ 0 in
    if not (Ctypes.is_null gerr__)
    then begin
      let msg = getf (!@ gerr__) C.GError.message in
      if Ctypes.is_null msg
      then failwith "failed with null error message";
      let msg = C.strdup msg in
      C.GError.free gerr__;
      failwith msg
    end;
    res

  let append_nulls t__ n =
    let gerr__ = CArray.make (ptr C.GError.t) 1 in
    let res = C.IntArrayBuilder.append_nulls t__ n (CArray.start gerr__) in
    let gerr__ = CArray.get gerr__ 0 in
    if not (Ctypes.is_null gerr__)
    then begin
      let msg = getf (!@ gerr__) C.GError.message in
      if Ctypes.is_null msg
      then failwith "failed with null error message";
      let msg = C.strdup msg in
      C.GError.free gerr__;
      failwith msg
    end;
    res

  let append_value t__ value =
    let gerr__ = CArray.make (ptr C.GError.t) 1 in
    let res = C.IntArrayBuilder.append_value t__ value (CArray.start gerr__) in
    let gerr__ = CArray.get gerr__ 0 in
    if not (Ctypes.is_null gerr__)
    then begin
      let msg = getf (!@ gerr__) C.GError.message in
      if Ctypes.is_null msg
      then failwith "failed with null error message";
      let msg = C.strdup msg in
      C.GError.free gerr__;
      failwith msg
    end;
    res

end

module IntegerDataType = struct
  type t = [ `integer_data_type | `numeric_data_type | `fixed_width_data_type | `data_type ] gobject
  let of_gobject g =
    if C.IntegerDataType.get_type () = C.gobject_type g
    then Some g else None

end

module ListArray = struct
  type t = [ `list_array | `array_ ] gobject
  let of_gobject g =
    if C.ListArray.get_type () = C.gobject_type g
    then Some g else None

  let new_ ?null_bitmap data_type length value_offsets values n_nulls =
    let res = C.ListArray.new_ data_type length value_offsets values (match null_bitmap with | None -> null | Some v -> v) n_nulls in
    if Ctypes.is_null res
    then failwith "returned null";
    Gc.finalise C.object_unref res;
    res

  let get_value t__ i =
    let res = C.ListArray.get_value t__ i in
    if Ctypes.is_null res
    then failwith "returned null";
    Gc.finalise C.object_unref res;
    res

  let get_value_type t__ =
    let res = C.ListArray.get_value_type t__ in
    if Ctypes.is_null res
    then failwith "returned null";
    Gc.finalise C.object_unref res;
    res

end

module ListArrayBuilder = struct
  type t = [ `list_array_builder | `array_builder ] gobject
  let of_gobject g =
    if C.ListArrayBuilder.get_type () = C.gobject_type g
    then Some g else None

  let new_ data_type =
    let gerr__ = CArray.make (ptr C.GError.t) 1 in
    let res = C.ListArrayBuilder.new_ data_type (CArray.start gerr__) in
    let gerr__ = CArray.get gerr__ 0 in
    if not (Ctypes.is_null gerr__)
    then begin
      let msg = getf (!@ gerr__) C.GError.message in
      if Ctypes.is_null msg
      then failwith "failed with null error message";
      let msg = C.strdup msg in
      C.GError.free gerr__;
      failwith msg
    end;
    if Ctypes.is_null res
    then failwith "returned null";
    Gc.finalise C.object_unref res;
    res

  let append_null t__ =
    let gerr__ = CArray.make (ptr C.GError.t) 1 in
    let res = C.ListArrayBuilder.append_null t__ (CArray.start gerr__) in
    let gerr__ = CArray.get gerr__ 0 in
    if not (Ctypes.is_null gerr__)
    then begin
      let msg = getf (!@ gerr__) C.GError.message in
      if Ctypes.is_null msg
      then failwith "failed with null error message";
      let msg = C.strdup msg in
      C.GError.free gerr__;
      failwith msg
    end;
    res

  let append_value t__ =
    let gerr__ = CArray.make (ptr C.GError.t) 1 in
    let res = C.ListArrayBuilder.append_value t__ (CArray.start gerr__) in
    let gerr__ = CArray.get gerr__ 0 in
    if not (Ctypes.is_null gerr__)
    then begin
      let msg = getf (!@ gerr__) C.GError.message in
      if Ctypes.is_null msg
      then failwith "failed with null error message";
      let msg = C.strdup msg in
      C.GError.free gerr__;
      failwith msg
    end;
    res

  let get_value_builder t__ =
    let res = C.ListArrayBuilder.get_value_builder t__ in
    if Ctypes.is_null res
    then failwith "returned null";
    Gc.finalise C.object_unref res;
    res

end

module ListDataType = struct
  type t = [ `list_data_type | `data_type ] gobject
  let of_gobject g =
    if C.ListDataType.get_type () = C.gobject_type g
    then Some g else None

  let new_ field =
    let res = C.ListDataType.new_ field in
    if Ctypes.is_null res
    then failwith "returned null";
    Gc.finalise C.object_unref res;
    res

  let get_field t__ =
    let res = C.ListDataType.get_field t__ in
    if Ctypes.is_null res
    then failwith "returned null";
    Gc.finalise C.object_unref res;
    res

end

module MemoryMappedInputStream = struct
  type t = [ `memory_mapped_input_stream | `seekable_input_stream | `input_stream ] gobject
  let of_gobject g =
    if C.MemoryMappedInputStream.get_type () = C.gobject_type g
    then Some g else None

  let new_ path =
    let gerr__ = CArray.make (ptr C.GError.t) 1 in
    let res = C.MemoryMappedInputStream.new_ path (CArray.start gerr__) in
    let gerr__ = CArray.get gerr__ 0 in
    if not (Ctypes.is_null gerr__)
    then begin
      let msg = getf (!@ gerr__) C.GError.message in
      if Ctypes.is_null msg
      then failwith "failed with null error message";
      let msg = C.strdup msg in
      C.GError.free gerr__;
      failwith msg
    end;
    if Ctypes.is_null res
    then failwith "returned null";
    Gc.finalise C.object_unref res;
    res

end

module MutableBuffer = struct
  type t = [ `mutable_buffer | `buffer ] gobject
  let of_gobject g =
    if C.MutableBuffer.get_type () = C.gobject_type g
    then Some g else None

  let slice t__ offset size =
    let res = C.MutableBuffer.slice t__ offset size in
    if Ctypes.is_null res
    then failwith "returned null";
    Gc.finalise C.object_unref res;
    res

end

module NullArray = struct
  type t = [ `null_array | `array_ ] gobject
  let of_gobject g =
    if C.NullArray.get_type () = C.gobject_type g
    then Some g else None

  let new_ length =
    let res = C.NullArray.new_ length in
    if Ctypes.is_null res
    then failwith "returned null";
    Gc.finalise C.object_unref res;
    res

end

module NullArrayBuilder = struct
  type t = [ `null_array_builder | `array_builder ] gobject
  let of_gobject g =
    if C.NullArrayBuilder.get_type () = C.gobject_type g
    then Some g else None

  let new_ () =
    let res = C.NullArrayBuilder.new_ () in
    if Ctypes.is_null res
    then failwith "returned null";
    Gc.finalise C.object_unref res;
    res

  let append_null t__ =
    let gerr__ = CArray.make (ptr C.GError.t) 1 in
    let res = C.NullArrayBuilder.append_null t__ (CArray.start gerr__) in
    let gerr__ = CArray.get gerr__ 0 in
    if not (Ctypes.is_null gerr__)
    then begin
      let msg = getf (!@ gerr__) C.GError.message in
      if Ctypes.is_null msg
      then failwith "failed with null error message";
      let msg = C.strdup msg in
      C.GError.free gerr__;
      failwith msg
    end;
    res

  let append_nulls t__ n =
    let gerr__ = CArray.make (ptr C.GError.t) 1 in
    let res = C.NullArrayBuilder.append_nulls t__ n (CArray.start gerr__) in
    let gerr__ = CArray.get gerr__ 0 in
    if not (Ctypes.is_null gerr__)
    then begin
      let msg = getf (!@ gerr__) C.GError.message in
      if Ctypes.is_null msg
      then failwith "failed with null error message";
      let msg = C.strdup msg in
      C.GError.free gerr__;
      failwith msg
    end;
    res

end

module NullDataType = struct
  type t = [ `null_data_type | `data_type ] gobject
  let of_gobject g =
    if C.NullDataType.get_type () = C.gobject_type g
    then Some g else None

  let new_ () =
    let res = C.NullDataType.new_ () in
    if Ctypes.is_null res
    then failwith "returned null";
    Gc.finalise C.object_unref res;
    res

end

module NumericArray = struct
  type t = [ `numeric_array | `primitive_array | `array_ ] gobject
  let of_gobject g =
    if C.NumericArray.get_type () = C.gobject_type g
    then Some g else None

  let mean t__ =
    let gerr__ = CArray.make (ptr C.GError.t) 1 in
    let res = C.NumericArray.mean t__ (CArray.start gerr__) in
    let gerr__ = CArray.get gerr__ 0 in
    if not (Ctypes.is_null gerr__)
    then begin
      let msg = getf (!@ gerr__) C.GError.message in
      if Ctypes.is_null msg
      then failwith "failed with null error message";
      let msg = C.strdup msg in
      C.GError.free gerr__;
      failwith msg
    end;
    res

end

module NumericDataType = struct
  type t = [ `numeric_data_type | `fixed_width_data_type | `data_type ] gobject
  let of_gobject g =
    if C.NumericDataType.get_type () = C.gobject_type g
    then Some g else None

end

module OutputStream = struct
  type t = [ `output_stream ] gobject
  let of_gobject g =
    if C.OutputStream.get_type () = C.gobject_type g
    then Some g else None

  let align t__ alignment =
    let gerr__ = CArray.make (ptr C.GError.t) 1 in
    let res = C.OutputStream.align t__ alignment (CArray.start gerr__) in
    let gerr__ = CArray.get gerr__ 0 in
    if not (Ctypes.is_null gerr__)
    then begin
      let msg = getf (!@ gerr__) C.GError.message in
      if Ctypes.is_null msg
      then failwith "failed with null error message";
      let msg = C.strdup msg in
      C.GError.free gerr__;
      failwith msg
    end;
    res

  let write_tensor t__ tensor =
    let gerr__ = CArray.make (ptr C.GError.t) 1 in
    let res = C.OutputStream.write_tensor t__ tensor (CArray.start gerr__) in
    let gerr__ = CArray.get gerr__ 0 in
    if not (Ctypes.is_null gerr__)
    then begin
      let msg = getf (!@ gerr__) C.GError.message in
      if Ctypes.is_null msg
      then failwith "failed with null error message";
      let msg = C.strdup msg in
      C.GError.free gerr__;
      failwith msg
    end;
    res

end

module PrimitiveArray = struct
  type t = [ `primitive_array | `array_ ] gobject
  let of_gobject g =
    if C.PrimitiveArray.get_type () = C.gobject_type g
    then Some g else None

  let get_buffer t__ =
    let res = C.PrimitiveArray.get_buffer t__ in
    if Ctypes.is_null res
    then failwith "returned null";
    Gc.finalise C.object_unref res;
    res

end

module RecordBatch = struct
  type t = [ `record_batch ] gobject
  let of_gobject g =
    if C.RecordBatch.get_type () = C.gobject_type g
    then Some g else None

  let add_column t__ i field column =
    let gerr__ = CArray.make (ptr C.GError.t) 1 in
    let res = C.RecordBatch.add_column t__ i field column (CArray.start gerr__) in
    let gerr__ = CArray.get gerr__ 0 in
    if not (Ctypes.is_null gerr__)
    then begin
      let msg = getf (!@ gerr__) C.GError.message in
      if Ctypes.is_null msg
      then failwith "failed with null error message";
      let msg = C.strdup msg in
      C.GError.free gerr__;
      failwith msg
    end;
    if Ctypes.is_null res
    then failwith "returned null";
    Gc.finalise C.object_unref res;
    res

  let equal t__ other_record_batch =
    let res = C.RecordBatch.equal t__ other_record_batch in
    res

  let get_column t__ i =
    let res = C.RecordBatch.get_column t__ i in
    if Ctypes.is_null res
    then failwith "returned null";
    Gc.finalise C.object_unref res;
    res

  let get_column_name t__ i =
    let res = C.RecordBatch.get_column_name t__ i in
    res

  let get_n_columns t__ =
    let res = C.RecordBatch.get_n_columns t__ in
    res

  let get_n_rows t__ =
    let res = C.RecordBatch.get_n_rows t__ in
    res

  let get_schema t__ =
    let res = C.RecordBatch.get_schema t__ in
    if Ctypes.is_null res
    then failwith "returned null";
    Gc.finalise C.object_unref res;
    res

  let remove_column t__ i =
    let gerr__ = CArray.make (ptr C.GError.t) 1 in
    let res = C.RecordBatch.remove_column t__ i (CArray.start gerr__) in
    let gerr__ = CArray.get gerr__ 0 in
    if not (Ctypes.is_null gerr__)
    then begin
      let msg = getf (!@ gerr__) C.GError.message in
      if Ctypes.is_null msg
      then failwith "failed with null error message";
      let msg = C.strdup msg in
      C.GError.free gerr__;
      failwith msg
    end;
    if Ctypes.is_null res
    then failwith "returned null";
    Gc.finalise C.object_unref res;
    res

  let slice t__ offset length =
    let res = C.RecordBatch.slice t__ offset length in
    if Ctypes.is_null res
    then failwith "returned null";
    Gc.finalise C.object_unref res;
    res

  let to_string t__ =
    let gerr__ = CArray.make (ptr C.GError.t) 1 in
    let res = C.RecordBatch.to_string t__ (CArray.start gerr__) in
    let gerr__ = CArray.get gerr__ 0 in
    if not (Ctypes.is_null gerr__)
    then begin
      let msg = getf (!@ gerr__) C.GError.message in
      if Ctypes.is_null msg
      then failwith "failed with null error message";
      let msg = C.strdup msg in
      C.GError.free gerr__;
      failwith msg
    end;
    res

end

module RecordBatchBuilder = struct
  type t = [ `record_batch_builder ] gobject
  let of_gobject g =
    if C.RecordBatchBuilder.get_type () = C.gobject_type g
    then Some g else None

  let new_ schema =
    let gerr__ = CArray.make (ptr C.GError.t) 1 in
    let res = C.RecordBatchBuilder.new_ schema (CArray.start gerr__) in
    let gerr__ = CArray.get gerr__ 0 in
    if not (Ctypes.is_null gerr__)
    then begin
      let msg = getf (!@ gerr__) C.GError.message in
      if Ctypes.is_null msg
      then failwith "failed with null error message";
      let msg = C.strdup msg in
      C.GError.free gerr__;
      failwith msg
    end;
    if Ctypes.is_null res
    then failwith "returned null";
    Gc.finalise C.object_unref res;
    res

  let flush t__ =
    let gerr__ = CArray.make (ptr C.GError.t) 1 in
    let res = C.RecordBatchBuilder.flush t__ (CArray.start gerr__) in
    let gerr__ = CArray.get gerr__ 0 in
    if not (Ctypes.is_null gerr__)
    then begin
      let msg = getf (!@ gerr__) C.GError.message in
      if Ctypes.is_null msg
      then failwith "failed with null error message";
      let msg = C.strdup msg in
      C.GError.free gerr__;
      failwith msg
    end;
    if Ctypes.is_null res
    then failwith "returned null";
    Gc.finalise C.object_unref res;
    res

  let get_column_builder t__ i =
    let res = C.RecordBatchBuilder.get_column_builder t__ i in
    if Ctypes.is_null res
    then failwith "returned null";
    Gc.finalise C.object_unref res;
    res

  let get_initial_capacity t__ =
    let res = C.RecordBatchBuilder.get_initial_capacity t__ in
    res

  let get_n_columns t__ =
    let res = C.RecordBatchBuilder.get_n_columns t__ in
    res

  let get_schema t__ =
    let res = C.RecordBatchBuilder.get_schema t__ in
    if Ctypes.is_null res
    then failwith "returned null";
    Gc.finalise C.object_unref res;
    res

end

module RecordBatchFileReader = struct
  type t = [ `record_batch_file_reader ] gobject
  let of_gobject g =
    if C.RecordBatchFileReader.get_type () = C.gobject_type g
    then Some g else None

  let new_ file =
    let gerr__ = CArray.make (ptr C.GError.t) 1 in
    let res = C.RecordBatchFileReader.new_ file (CArray.start gerr__) in
    let gerr__ = CArray.get gerr__ 0 in
    if not (Ctypes.is_null gerr__)
    then begin
      let msg = getf (!@ gerr__) C.GError.message in
      if Ctypes.is_null msg
      then failwith "failed with null error message";
      let msg = C.strdup msg in
      C.GError.free gerr__;
      failwith msg
    end;
    if Ctypes.is_null res
    then failwith "returned null";
    Gc.finalise C.object_unref res;
    res

  let get_n_record_batches t__ =
    let res = C.RecordBatchFileReader.get_n_record_batches t__ in
    res

  let get_schema t__ =
    let res = C.RecordBatchFileReader.get_schema t__ in
    if Ctypes.is_null res
    then failwith "returned null";
    Gc.finalise C.object_unref res;
    res

  let read_record_batch t__ i =
    let gerr__ = CArray.make (ptr C.GError.t) 1 in
    let res = C.RecordBatchFileReader.read_record_batch t__ i (CArray.start gerr__) in
    let gerr__ = CArray.get gerr__ 0 in
    if not (Ctypes.is_null gerr__)
    then begin
      let msg = getf (!@ gerr__) C.GError.message in
      if Ctypes.is_null msg
      then failwith "failed with null error message";
      let msg = C.strdup msg in
      C.GError.free gerr__;
      failwith msg
    end;
    if Ctypes.is_null res
    then failwith "returned null";
    Gc.finalise C.object_unref res;
    res

end

module RecordBatchFileWriter = struct
  type t = [ `record_batch_file_writer | `record_batch_stream_writer | `record_batch_writer ] gobject
  let of_gobject g =
    if C.RecordBatchFileWriter.get_type () = C.gobject_type g
    then Some g else None

  let new_ sink schema =
    let gerr__ = CArray.make (ptr C.GError.t) 1 in
    let res = C.RecordBatchFileWriter.new_ sink schema (CArray.start gerr__) in
    let gerr__ = CArray.get gerr__ 0 in
    if not (Ctypes.is_null gerr__)
    then begin
      let msg = getf (!@ gerr__) C.GError.message in
      if Ctypes.is_null msg
      then failwith "failed with null error message";
      let msg = C.strdup msg in
      C.GError.free gerr__;
      failwith msg
    end;
    if Ctypes.is_null res
    then failwith "returned null";
    Gc.finalise C.object_unref res;
    res

end

module RecordBatchReader = struct
  type t = [ `record_batch_reader ] gobject
  let of_gobject g =
    if C.RecordBatchReader.get_type () = C.gobject_type g
    then Some g else None

  let get_schema t__ =
    let res = C.RecordBatchReader.get_schema t__ in
    if Ctypes.is_null res
    then failwith "returned null";
    Gc.finalise C.object_unref res;
    res

  let read_next t__ =
    let gerr__ = CArray.make (ptr C.GError.t) 1 in
    let res = C.RecordBatchReader.read_next t__ (CArray.start gerr__) in
    let gerr__ = CArray.get gerr__ 0 in
    if not (Ctypes.is_null gerr__)
    then begin
      let msg = getf (!@ gerr__) C.GError.message in
      if Ctypes.is_null msg
      then failwith "failed with null error message";
      let msg = C.strdup msg in
      C.GError.free gerr__;
      failwith msg
    end;
    if Ctypes.is_null res
    then failwith "returned null";
    Gc.finalise C.object_unref res;
    res

end

module RecordBatchStreamReader = struct
  type t = [ `record_batch_stream_reader | `record_batch_reader ] gobject
  let of_gobject g =
    if C.RecordBatchStreamReader.get_type () = C.gobject_type g
    then Some g else None

  let new_ stream =
    let gerr__ = CArray.make (ptr C.GError.t) 1 in
    let res = C.RecordBatchStreamReader.new_ stream (CArray.start gerr__) in
    let gerr__ = CArray.get gerr__ 0 in
    if not (Ctypes.is_null gerr__)
    then begin
      let msg = getf (!@ gerr__) C.GError.message in
      if Ctypes.is_null msg
      then failwith "failed with null error message";
      let msg = C.strdup msg in
      C.GError.free gerr__;
      failwith msg
    end;
    if Ctypes.is_null res
    then failwith "returned null";
    Gc.finalise C.object_unref res;
    res

end

module RecordBatchStreamWriter = struct
  type t = [ `record_batch_stream_writer | `record_batch_writer ] gobject
  let of_gobject g =
    if C.RecordBatchStreamWriter.get_type () = C.gobject_type g
    then Some g else None

  let new_ sink schema =
    let gerr__ = CArray.make (ptr C.GError.t) 1 in
    let res = C.RecordBatchStreamWriter.new_ sink schema (CArray.start gerr__) in
    let gerr__ = CArray.get gerr__ 0 in
    if not (Ctypes.is_null gerr__)
    then begin
      let msg = getf (!@ gerr__) C.GError.message in
      if Ctypes.is_null msg
      then failwith "failed with null error message";
      let msg = C.strdup msg in
      C.GError.free gerr__;
      failwith msg
    end;
    if Ctypes.is_null res
    then failwith "returned null";
    Gc.finalise C.object_unref res;
    res

end

module RecordBatchWriter = struct
  type t = [ `record_batch_writer ] gobject
  let of_gobject g =
    if C.RecordBatchWriter.get_type () = C.gobject_type g
    then Some g else None

  let close t__ =
    let gerr__ = CArray.make (ptr C.GError.t) 1 in
    let res = C.RecordBatchWriter.close t__ (CArray.start gerr__) in
    let gerr__ = CArray.get gerr__ 0 in
    if not (Ctypes.is_null gerr__)
    then begin
      let msg = getf (!@ gerr__) C.GError.message in
      if Ctypes.is_null msg
      then failwith "failed with null error message";
      let msg = C.strdup msg in
      C.GError.free gerr__;
      failwith msg
    end;
    res

  let write_record_batch t__ record_batch =
    let gerr__ = CArray.make (ptr C.GError.t) 1 in
    let res = C.RecordBatchWriter.write_record_batch t__ record_batch (CArray.start gerr__) in
    let gerr__ = CArray.get gerr__ 0 in
    if not (Ctypes.is_null gerr__)
    then begin
      let msg = getf (!@ gerr__) C.GError.message in
      if Ctypes.is_null msg
      then failwith "failed with null error message";
      let msg = C.strdup msg in
      C.GError.free gerr__;
      failwith msg
    end;
    res

  let write_table t__ table =
    let gerr__ = CArray.make (ptr C.GError.t) 1 in
    let res = C.RecordBatchWriter.write_table t__ table (CArray.start gerr__) in
    let gerr__ = CArray.get gerr__ 0 in
    if not (Ctypes.is_null gerr__)
    then begin
      let msg = getf (!@ gerr__) C.GError.message in
      if Ctypes.is_null msg
      then failwith "failed with null error message";
      let msg = C.strdup msg in
      C.GError.free gerr__;
      failwith msg
    end;
    res

end

module ResizableBuffer = struct
  type t = [ `resizable_buffer | `mutable_buffer | `buffer ] gobject
  let of_gobject g =
    if C.ResizableBuffer.get_type () = C.gobject_type g
    then Some g else None

  let new_ initial_size =
    let gerr__ = CArray.make (ptr C.GError.t) 1 in
    let res = C.ResizableBuffer.new_ initial_size (CArray.start gerr__) in
    let gerr__ = CArray.get gerr__ 0 in
    if not (Ctypes.is_null gerr__)
    then begin
      let msg = getf (!@ gerr__) C.GError.message in
      if Ctypes.is_null msg
      then failwith "failed with null error message";
      let msg = C.strdup msg in
      C.GError.free gerr__;
      failwith msg
    end;
    if Ctypes.is_null res
    then failwith "returned null";
    Gc.finalise C.object_unref res;
    res

  let reserve t__ new_capacity =
    let gerr__ = CArray.make (ptr C.GError.t) 1 in
    let res = C.ResizableBuffer.reserve t__ new_capacity (CArray.start gerr__) in
    let gerr__ = CArray.get gerr__ 0 in
    if not (Ctypes.is_null gerr__)
    then begin
      let msg = getf (!@ gerr__) C.GError.message in
      if Ctypes.is_null msg
      then failwith "failed with null error message";
      let msg = C.strdup msg in
      C.GError.free gerr__;
      failwith msg
    end;
    res

  let resize t__ new_size =
    let gerr__ = CArray.make (ptr C.GError.t) 1 in
    let res = C.ResizableBuffer.resize t__ new_size (CArray.start gerr__) in
    let gerr__ = CArray.get gerr__ 0 in
    if not (Ctypes.is_null gerr__)
    then begin
      let msg = getf (!@ gerr__) C.GError.message in
      if Ctypes.is_null msg
      then failwith "failed with null error message";
      let msg = C.strdup msg in
      C.GError.free gerr__;
      failwith msg
    end;
    res

end

module Schema = struct
  type t = [ `schema ] gobject
  let of_gobject g =
    if C.Schema.get_type () = C.gobject_type g
    then Some g else None

  let add_field t__ i field =
    let gerr__ = CArray.make (ptr C.GError.t) 1 in
    let res = C.Schema.add_field t__ i field (CArray.start gerr__) in
    let gerr__ = CArray.get gerr__ 0 in
    if not (Ctypes.is_null gerr__)
    then begin
      let msg = getf (!@ gerr__) C.GError.message in
      if Ctypes.is_null msg
      then failwith "failed with null error message";
      let msg = C.strdup msg in
      C.GError.free gerr__;
      failwith msg
    end;
    if Ctypes.is_null res
    then failwith "returned null";
    Gc.finalise C.object_unref res;
    res

  let equal t__ other_schema =
    let res = C.Schema.equal t__ other_schema in
    res

  let get_field t__ i =
    let res = C.Schema.get_field t__ i in
    if Ctypes.is_null res
    then failwith "returned null";
    Gc.finalise C.object_unref res;
    res

  let get_field_by_name t__ name =
    let res = C.Schema.get_field_by_name t__ name in
    if Ctypes.is_null res
    then failwith "returned null";
    Gc.finalise C.object_unref res;
    res

  let n_fields t__ =
    let res = C.Schema.n_fields t__ in
    res

  let remove_field t__ i =
    let gerr__ = CArray.make (ptr C.GError.t) 1 in
    let res = C.Schema.remove_field t__ i (CArray.start gerr__) in
    let gerr__ = CArray.get gerr__ 0 in
    if not (Ctypes.is_null gerr__)
    then begin
      let msg = getf (!@ gerr__) C.GError.message in
      if Ctypes.is_null msg
      then failwith "failed with null error message";
      let msg = C.strdup msg in
      C.GError.free gerr__;
      failwith msg
    end;
    if Ctypes.is_null res
    then failwith "returned null";
    Gc.finalise C.object_unref res;
    res

  let replace_field t__ i field =
    let gerr__ = CArray.make (ptr C.GError.t) 1 in
    let res = C.Schema.replace_field t__ i field (CArray.start gerr__) in
    let gerr__ = CArray.get gerr__ 0 in
    if not (Ctypes.is_null gerr__)
    then begin
      let msg = getf (!@ gerr__) C.GError.message in
      if Ctypes.is_null msg
      then failwith "failed with null error message";
      let msg = C.strdup msg in
      C.GError.free gerr__;
      failwith msg
    end;
    if Ctypes.is_null res
    then failwith "returned null";
    Gc.finalise C.object_unref res;
    res

  let to_string t__ =
    let res = C.Schema.to_string t__ in
    res

end

module SeekableInputStream = struct
  type t = [ `seekable_input_stream | `input_stream ] gobject
  let of_gobject g =
    if C.SeekableInputStream.get_type () = C.gobject_type g
    then Some g else None

  let get_size t__ =
    let gerr__ = CArray.make (ptr C.GError.t) 1 in
    let res = C.SeekableInputStream.get_size t__ (CArray.start gerr__) in
    let gerr__ = CArray.get gerr__ 0 in
    if not (Ctypes.is_null gerr__)
    then begin
      let msg = getf (!@ gerr__) C.GError.message in
      if Ctypes.is_null msg
      then failwith "failed with null error message";
      let msg = C.strdup msg in
      C.GError.free gerr__;
      failwith msg
    end;
    res

  let get_support_zero_copy t__ =
    let res = C.SeekableInputStream.get_support_zero_copy t__ in
    res

  let read_at t__ position n_bytes =
    let gerr__ = CArray.make (ptr C.GError.t) 1 in
    let res = C.SeekableInputStream.read_at t__ position n_bytes (CArray.start gerr__) in
    let gerr__ = CArray.get gerr__ 0 in
    if not (Ctypes.is_null gerr__)
    then begin
      let msg = getf (!@ gerr__) C.GError.message in
      if Ctypes.is_null msg
      then failwith "failed with null error message";
      let msg = C.strdup msg in
      C.GError.free gerr__;
      failwith msg
    end;
    if Ctypes.is_null res
    then failwith "returned null";
    Gc.finalise C.object_unref res;
    res

end

module SparseUnionArray = struct
  type t = [ `sparse_union_array | `union_array | `array_ ] gobject
  let of_gobject g =
    if C.SparseUnionArray.get_type () = C.gobject_type g
    then Some g else None

end

module SparseUnionDataType = struct
  type t = [ `sparse_union_data_type | `union_data_type | `data_type ] gobject
  let of_gobject g =
    if C.SparseUnionDataType.get_type () = C.gobject_type g
    then Some g else None

end

module StringArray = struct
  type t = [ `string_array | `binary_array | `array_ ] gobject
  let of_gobject g =
    if C.StringArray.get_type () = C.gobject_type g
    then Some g else None

  let new_ ?null_bitmap length value_offsets data n_nulls =
    let res = C.StringArray.new_ length value_offsets data (match null_bitmap with | None -> null | Some v -> v) n_nulls in
    if Ctypes.is_null res
    then failwith "returned null";
    Gc.finalise C.object_unref res;
    res

  let get_string t__ i =
    let res = C.StringArray.get_string t__ i in
    res

end

module StringArrayBuilder = struct
  type t = [ `string_array_builder | `binary_array_builder | `array_builder ] gobject
  let of_gobject g =
    if C.StringArrayBuilder.get_type () = C.gobject_type g
    then Some g else None

  let new_ () =
    let res = C.StringArrayBuilder.new_ () in
    if Ctypes.is_null res
    then failwith "returned null";
    Gc.finalise C.object_unref res;
    res

  let append_value t__ value =
    let gerr__ = CArray.make (ptr C.GError.t) 1 in
    let res = C.StringArrayBuilder.append_value t__ value (CArray.start gerr__) in
    let gerr__ = CArray.get gerr__ 0 in
    if not (Ctypes.is_null gerr__)
    then begin
      let msg = getf (!@ gerr__) C.GError.message in
      if Ctypes.is_null msg
      then failwith "failed with null error message";
      let msg = C.strdup msg in
      C.GError.free gerr__;
      failwith msg
    end;
    res

end

module StringDataType = struct
  type t = [ `string_data_type | `data_type ] gobject
  let of_gobject g =
    if C.StringDataType.get_type () = C.gobject_type g
    then Some g else None

  let new_ () =
    let res = C.StringDataType.new_ () in
    if Ctypes.is_null res
    then failwith "returned null";
    Gc.finalise C.object_unref res;
    res

end

module StructArray = struct
  type t = [ `struct_array | `array_ ] gobject
  let of_gobject g =
    if C.StructArray.get_type () = C.gobject_type g
    then Some g else None

  let get_field t__ i =
    let res = C.StructArray.get_field t__ i in
    if Ctypes.is_null res
    then failwith "returned null";
    Gc.finalise C.object_unref res;
    res

end

module StructArrayBuilder = struct
  type t = [ `struct_array_builder | `array_builder ] gobject
  let of_gobject g =
    if C.StructArrayBuilder.get_type () = C.gobject_type g
    then Some g else None

  let new_ data_type =
    let gerr__ = CArray.make (ptr C.GError.t) 1 in
    let res = C.StructArrayBuilder.new_ data_type (CArray.start gerr__) in
    let gerr__ = CArray.get gerr__ 0 in
    if not (Ctypes.is_null gerr__)
    then begin
      let msg = getf (!@ gerr__) C.GError.message in
      if Ctypes.is_null msg
      then failwith "failed with null error message";
      let msg = C.strdup msg in
      C.GError.free gerr__;
      failwith msg
    end;
    if Ctypes.is_null res
    then failwith "returned null";
    Gc.finalise C.object_unref res;
    res

  let append_null t__ =
    let gerr__ = CArray.make (ptr C.GError.t) 1 in
    let res = C.StructArrayBuilder.append_null t__ (CArray.start gerr__) in
    let gerr__ = CArray.get gerr__ 0 in
    if not (Ctypes.is_null gerr__)
    then begin
      let msg = getf (!@ gerr__) C.GError.message in
      if Ctypes.is_null msg
      then failwith "failed with null error message";
      let msg = C.strdup msg in
      C.GError.free gerr__;
      failwith msg
    end;
    res

  let append_value t__ =
    let gerr__ = CArray.make (ptr C.GError.t) 1 in
    let res = C.StructArrayBuilder.append_value t__ (CArray.start gerr__) in
    let gerr__ = CArray.get gerr__ 0 in
    if not (Ctypes.is_null gerr__)
    then begin
      let msg = getf (!@ gerr__) C.GError.message in
      if Ctypes.is_null msg
      then failwith "failed with null error message";
      let msg = C.strdup msg in
      C.GError.free gerr__;
      failwith msg
    end;
    res

  let get_field_builder t__ i =
    let res = C.StructArrayBuilder.get_field_builder t__ i in
    if Ctypes.is_null res
    then failwith "returned null";
    Gc.finalise C.object_unref res;
    res

end

module StructDataType = struct
  type t = [ `struct_data_type | `data_type ] gobject
  let of_gobject g =
    if C.StructDataType.get_type () = C.gobject_type g
    then Some g else None

  let get_field t__ i =
    let res = C.StructDataType.get_field t__ i in
    if Ctypes.is_null res
    then failwith "returned null";
    Gc.finalise C.object_unref res;
    res

  let get_field_by_name t__ name =
    let res = C.StructDataType.get_field_by_name t__ name in
    if Ctypes.is_null res
    then failwith "returned null";
    Gc.finalise C.object_unref res;
    res

  let get_field_index t__ name =
    let res = C.StructDataType.get_field_index t__ name in
    res

  let get_n_fields t__ =
    let res = C.StructDataType.get_n_fields t__ in
    res

end

module Table = struct
  type t = [ `table ] gobject
  let of_gobject g =
    if C.Table.get_type () = C.gobject_type g
    then Some g else None

  let add_column t__ i column =
    let gerr__ = CArray.make (ptr C.GError.t) 1 in
    let res = C.Table.add_column t__ i column (CArray.start gerr__) in
    let gerr__ = CArray.get gerr__ 0 in
    if not (Ctypes.is_null gerr__)
    then begin
      let msg = getf (!@ gerr__) C.GError.message in
      if Ctypes.is_null msg
      then failwith "failed with null error message";
      let msg = C.strdup msg in
      C.GError.free gerr__;
      failwith msg
    end;
    if Ctypes.is_null res
    then failwith "returned null";
    Gc.finalise C.object_unref res;
    res

  let equal t__ other_table =
    let res = C.Table.equal t__ other_table in
    res

  let get_column t__ i =
    let res = C.Table.get_column t__ i in
    if Ctypes.is_null res
    then failwith "returned null";
    Gc.finalise C.object_unref res;
    res

  let get_n_columns t__ =
    let res = C.Table.get_n_columns t__ in
    res

  let get_n_rows t__ =
    let res = C.Table.get_n_rows t__ in
    res

  let get_schema t__ =
    let res = C.Table.get_schema t__ in
    if Ctypes.is_null res
    then failwith "returned null";
    Gc.finalise C.object_unref res;
    res

  let remove_column t__ i =
    let gerr__ = CArray.make (ptr C.GError.t) 1 in
    let res = C.Table.remove_column t__ i (CArray.start gerr__) in
    let gerr__ = CArray.get gerr__ 0 in
    if not (Ctypes.is_null gerr__)
    then begin
      let msg = getf (!@ gerr__) C.GError.message in
      if Ctypes.is_null msg
      then failwith "failed with null error message";
      let msg = C.strdup msg in
      C.GError.free gerr__;
      failwith msg
    end;
    if Ctypes.is_null res
    then failwith "returned null";
    Gc.finalise C.object_unref res;
    res

  let replace_column t__ i column =
    let gerr__ = CArray.make (ptr C.GError.t) 1 in
    let res = C.Table.replace_column t__ i column (CArray.start gerr__) in
    let gerr__ = CArray.get gerr__ 0 in
    if not (Ctypes.is_null gerr__)
    then begin
      let msg = getf (!@ gerr__) C.GError.message in
      if Ctypes.is_null msg
      then failwith "failed with null error message";
      let msg = C.strdup msg in
      C.GError.free gerr__;
      failwith msg
    end;
    if Ctypes.is_null res
    then failwith "returned null";
    Gc.finalise C.object_unref res;
    res

  let to_string t__ =
    let gerr__ = CArray.make (ptr C.GError.t) 1 in
    let res = C.Table.to_string t__ (CArray.start gerr__) in
    let gerr__ = CArray.get gerr__ 0 in
    if not (Ctypes.is_null gerr__)
    then begin
      let msg = getf (!@ gerr__) C.GError.message in
      if Ctypes.is_null msg
      then failwith "failed with null error message";
      let msg = C.strdup msg in
      C.GError.free gerr__;
      failwith msg
    end;
    res

end

module TableBatchReader = struct
  type t = [ `table_batch_reader | `record_batch_reader ] gobject
  let of_gobject g =
    if C.TableBatchReader.get_type () = C.gobject_type g
    then Some g else None

  let new_ table =
    let res = C.TableBatchReader.new_ table in
    if Ctypes.is_null res
    then failwith "returned null";
    Gc.finalise C.object_unref res;
    res

end

module Tensor = struct
  type t = [ `tensor ] gobject
  let of_gobject g =
    if C.Tensor.get_type () = C.gobject_type g
    then Some g else None

  let equal t__ other_tensor =
    let res = C.Tensor.equal t__ other_tensor in
    res

  let get_buffer t__ =
    let res = C.Tensor.get_buffer t__ in
    if Ctypes.is_null res
    then failwith "returned null";
    Gc.finalise C.object_unref res;
    res

  let get_dimension_name t__ i =
    let res = C.Tensor.get_dimension_name t__ i in
    res

  let get_n_dimensions t__ =
    let res = C.Tensor.get_n_dimensions t__ in
    res

  let get_size t__ =
    let res = C.Tensor.get_size t__ in
    res

  let get_value_data_type t__ =
    let res = C.Tensor.get_value_data_type t__ in
    if Ctypes.is_null res
    then failwith "returned null";
    Gc.finalise C.object_unref res;
    res

  let is_column_major t__ =
    let res = C.Tensor.is_column_major t__ in
    res

  let is_contiguous t__ =
    let res = C.Tensor.is_contiguous t__ in
    res

  let is_mutable t__ =
    let res = C.Tensor.is_mutable t__ in
    res

  let is_row_major t__ =
    let res = C.Tensor.is_row_major t__ in
    res

end

module Time32Array = struct
  type t = [ `time32_array | `numeric_array | `primitive_array | `array_ ] gobject
  let of_gobject g =
    if C.Time32Array.get_type () = C.gobject_type g
    then Some g else None

  let new_ ?null_bitmap data_type length data n_nulls =
    let res = C.Time32Array.new_ data_type length data (match null_bitmap with | None -> null | Some v -> v) n_nulls in
    if Ctypes.is_null res
    then failwith "returned null";
    Gc.finalise C.object_unref res;
    res

  let get_value t__ i =
    let res = C.Time32Array.get_value t__ i in
    res

end

module Time32ArrayBuilder = struct
  type t = [ `time32_array_builder | `array_builder ] gobject
  let of_gobject g =
    if C.Time32ArrayBuilder.get_type () = C.gobject_type g
    then Some g else None

  let new_ data_type =
    let res = C.Time32ArrayBuilder.new_ data_type in
    if Ctypes.is_null res
    then failwith "returned null";
    Gc.finalise C.object_unref res;
    res

  let append_null t__ =
    let gerr__ = CArray.make (ptr C.GError.t) 1 in
    let res = C.Time32ArrayBuilder.append_null t__ (CArray.start gerr__) in
    let gerr__ = CArray.get gerr__ 0 in
    if not (Ctypes.is_null gerr__)
    then begin
      let msg = getf (!@ gerr__) C.GError.message in
      if Ctypes.is_null msg
      then failwith "failed with null error message";
      let msg = C.strdup msg in
      C.GError.free gerr__;
      failwith msg
    end;
    res

  let append_nulls t__ n =
    let gerr__ = CArray.make (ptr C.GError.t) 1 in
    let res = C.Time32ArrayBuilder.append_nulls t__ n (CArray.start gerr__) in
    let gerr__ = CArray.get gerr__ 0 in
    if not (Ctypes.is_null gerr__)
    then begin
      let msg = getf (!@ gerr__) C.GError.message in
      if Ctypes.is_null msg
      then failwith "failed with null error message";
      let msg = C.strdup msg in
      C.GError.free gerr__;
      failwith msg
    end;
    res

  let append_value t__ value =
    let gerr__ = CArray.make (ptr C.GError.t) 1 in
    let res = C.Time32ArrayBuilder.append_value t__ value (CArray.start gerr__) in
    let gerr__ = CArray.get gerr__ 0 in
    if not (Ctypes.is_null gerr__)
    then begin
      let msg = getf (!@ gerr__) C.GError.message in
      if Ctypes.is_null msg
      then failwith "failed with null error message";
      let msg = C.strdup msg in
      C.GError.free gerr__;
      failwith msg
    end;
    res

end

module Time32DataType = struct
  type t = [ `time32_data_type | `time_data_type | `data_type ] gobject
  let of_gobject g =
    if C.Time32DataType.get_type () = C.gobject_type g
    then Some g else None

end

module Time64Array = struct
  type t = [ `time64_array | `numeric_array | `primitive_array | `array_ ] gobject
  let of_gobject g =
    if C.Time64Array.get_type () = C.gobject_type g
    then Some g else None

  let new_ ?null_bitmap data_type length data n_nulls =
    let res = C.Time64Array.new_ data_type length data (match null_bitmap with | None -> null | Some v -> v) n_nulls in
    if Ctypes.is_null res
    then failwith "returned null";
    Gc.finalise C.object_unref res;
    res

  let get_value t__ i =
    let res = C.Time64Array.get_value t__ i in
    res

end

module Time64ArrayBuilder = struct
  type t = [ `time64_array_builder | `array_builder ] gobject
  let of_gobject g =
    if C.Time64ArrayBuilder.get_type () = C.gobject_type g
    then Some g else None

  let new_ data_type =
    let res = C.Time64ArrayBuilder.new_ data_type in
    if Ctypes.is_null res
    then failwith "returned null";
    Gc.finalise C.object_unref res;
    res

  let append_null t__ =
    let gerr__ = CArray.make (ptr C.GError.t) 1 in
    let res = C.Time64ArrayBuilder.append_null t__ (CArray.start gerr__) in
    let gerr__ = CArray.get gerr__ 0 in
    if not (Ctypes.is_null gerr__)
    then begin
      let msg = getf (!@ gerr__) C.GError.message in
      if Ctypes.is_null msg
      then failwith "failed with null error message";
      let msg = C.strdup msg in
      C.GError.free gerr__;
      failwith msg
    end;
    res

  let append_nulls t__ n =
    let gerr__ = CArray.make (ptr C.GError.t) 1 in
    let res = C.Time64ArrayBuilder.append_nulls t__ n (CArray.start gerr__) in
    let gerr__ = CArray.get gerr__ 0 in
    if not (Ctypes.is_null gerr__)
    then begin
      let msg = getf (!@ gerr__) C.GError.message in
      if Ctypes.is_null msg
      then failwith "failed with null error message";
      let msg = C.strdup msg in
      C.GError.free gerr__;
      failwith msg
    end;
    res

  let append_value t__ value =
    let gerr__ = CArray.make (ptr C.GError.t) 1 in
    let res = C.Time64ArrayBuilder.append_value t__ value (CArray.start gerr__) in
    let gerr__ = CArray.get gerr__ 0 in
    if not (Ctypes.is_null gerr__)
    then begin
      let msg = getf (!@ gerr__) C.GError.message in
      if Ctypes.is_null msg
      then failwith "failed with null error message";
      let msg = C.strdup msg in
      C.GError.free gerr__;
      failwith msg
    end;
    res

end

module Time64DataType = struct
  type t = [ `time64_data_type | `time_data_type | `data_type ] gobject
  let of_gobject g =
    if C.Time64DataType.get_type () = C.gobject_type g
    then Some g else None

end

module TimeDataType = struct
  type t = [ `time_data_type | `data_type ] gobject
  let of_gobject g =
    if C.TimeDataType.get_type () = C.gobject_type g
    then Some g else None

end

module TimestampArray = struct
  type t = [ `timestamp_array | `numeric_array | `primitive_array | `array_ ] gobject
  let of_gobject g =
    if C.TimestampArray.get_type () = C.gobject_type g
    then Some g else None

  let new_ ?null_bitmap data_type length data n_nulls =
    let res = C.TimestampArray.new_ data_type length data (match null_bitmap with | None -> null | Some v -> v) n_nulls in
    if Ctypes.is_null res
    then failwith "returned null";
    Gc.finalise C.object_unref res;
    res

  let get_value t__ i =
    let res = C.TimestampArray.get_value t__ i in
    res

end

module TimestampArrayBuilder = struct
  type t = [ `timestamp_array_builder | `array_builder ] gobject
  let of_gobject g =
    if C.TimestampArrayBuilder.get_type () = C.gobject_type g
    then Some g else None

  let new_ data_type =
    let res = C.TimestampArrayBuilder.new_ data_type in
    if Ctypes.is_null res
    then failwith "returned null";
    Gc.finalise C.object_unref res;
    res

  let append_null t__ =
    let gerr__ = CArray.make (ptr C.GError.t) 1 in
    let res = C.TimestampArrayBuilder.append_null t__ (CArray.start gerr__) in
    let gerr__ = CArray.get gerr__ 0 in
    if not (Ctypes.is_null gerr__)
    then begin
      let msg = getf (!@ gerr__) C.GError.message in
      if Ctypes.is_null msg
      then failwith "failed with null error message";
      let msg = C.strdup msg in
      C.GError.free gerr__;
      failwith msg
    end;
    res

  let append_nulls t__ n =
    let gerr__ = CArray.make (ptr C.GError.t) 1 in
    let res = C.TimestampArrayBuilder.append_nulls t__ n (CArray.start gerr__) in
    let gerr__ = CArray.get gerr__ 0 in
    if not (Ctypes.is_null gerr__)
    then begin
      let msg = getf (!@ gerr__) C.GError.message in
      if Ctypes.is_null msg
      then failwith "failed with null error message";
      let msg = C.strdup msg in
      C.GError.free gerr__;
      failwith msg
    end;
    res

  let append_value t__ value =
    let gerr__ = CArray.make (ptr C.GError.t) 1 in
    let res = C.TimestampArrayBuilder.append_value t__ value (CArray.start gerr__) in
    let gerr__ = CArray.get gerr__ 0 in
    if not (Ctypes.is_null gerr__)
    then begin
      let msg = getf (!@ gerr__) C.GError.message in
      if Ctypes.is_null msg
      then failwith "failed with null error message";
      let msg = C.strdup msg in
      C.GError.free gerr__;
      failwith msg
    end;
    res

end

module TimestampDataType = struct
  type t = [ `timestamp_data_type | `data_type ] gobject
  let of_gobject g =
    if C.TimestampDataType.get_type () = C.gobject_type g
    then Some g else None

end

module UInt16Array = struct
  type t = [ `u_int16_array | `numeric_array | `primitive_array | `array_ ] gobject
  let of_gobject g =
    if C.UInt16Array.get_type () = C.gobject_type g
    then Some g else None

  let new_ ?null_bitmap length data n_nulls =
    let res = C.UInt16Array.new_ length data (match null_bitmap with | None -> null | Some v -> v) n_nulls in
    if Ctypes.is_null res
    then failwith "returned null";
    Gc.finalise C.object_unref res;
    res

  let get_value t__ i =
    let res = C.UInt16Array.get_value t__ i in
    res

  let sum t__ =
    let gerr__ = CArray.make (ptr C.GError.t) 1 in
    let res = C.UInt16Array.sum t__ (CArray.start gerr__) in
    let gerr__ = CArray.get gerr__ 0 in
    if not (Ctypes.is_null gerr__)
    then begin
      let msg = getf (!@ gerr__) C.GError.message in
      if Ctypes.is_null msg
      then failwith "failed with null error message";
      let msg = C.strdup msg in
      C.GError.free gerr__;
      failwith msg
    end;
    res

end

module UInt16ArrayBuilder = struct
  type t = [ `u_int16_array_builder | `array_builder ] gobject
  let of_gobject g =
    if C.UInt16ArrayBuilder.get_type () = C.gobject_type g
    then Some g else None

  let new_ () =
    let res = C.UInt16ArrayBuilder.new_ () in
    if Ctypes.is_null res
    then failwith "returned null";
    Gc.finalise C.object_unref res;
    res

  let append_null t__ =
    let gerr__ = CArray.make (ptr C.GError.t) 1 in
    let res = C.UInt16ArrayBuilder.append_null t__ (CArray.start gerr__) in
    let gerr__ = CArray.get gerr__ 0 in
    if not (Ctypes.is_null gerr__)
    then begin
      let msg = getf (!@ gerr__) C.GError.message in
      if Ctypes.is_null msg
      then failwith "failed with null error message";
      let msg = C.strdup msg in
      C.GError.free gerr__;
      failwith msg
    end;
    res

  let append_nulls t__ n =
    let gerr__ = CArray.make (ptr C.GError.t) 1 in
    let res = C.UInt16ArrayBuilder.append_nulls t__ n (CArray.start gerr__) in
    let gerr__ = CArray.get gerr__ 0 in
    if not (Ctypes.is_null gerr__)
    then begin
      let msg = getf (!@ gerr__) C.GError.message in
      if Ctypes.is_null msg
      then failwith "failed with null error message";
      let msg = C.strdup msg in
      C.GError.free gerr__;
      failwith msg
    end;
    res

  let append_value t__ value =
    let gerr__ = CArray.make (ptr C.GError.t) 1 in
    let res = C.UInt16ArrayBuilder.append_value t__ value (CArray.start gerr__) in
    let gerr__ = CArray.get gerr__ 0 in
    if not (Ctypes.is_null gerr__)
    then begin
      let msg = getf (!@ gerr__) C.GError.message in
      if Ctypes.is_null msg
      then failwith "failed with null error message";
      let msg = C.strdup msg in
      C.GError.free gerr__;
      failwith msg
    end;
    res

end

module UInt16DataType = struct
  type t = [ `u_int16_data_type | `integer_data_type | `numeric_data_type | `fixed_width_data_type | `data_type ] gobject
  let of_gobject g =
    if C.UInt16DataType.get_type () = C.gobject_type g
    then Some g else None

  let new_ () =
    let res = C.UInt16DataType.new_ () in
    if Ctypes.is_null res
    then failwith "returned null";
    Gc.finalise C.object_unref res;
    res

end

module UInt32Array = struct
  type t = [ `u_int32_array | `numeric_array | `primitive_array | `array_ ] gobject
  let of_gobject g =
    if C.UInt32Array.get_type () = C.gobject_type g
    then Some g else None

  let new_ ?null_bitmap length data n_nulls =
    let res = C.UInt32Array.new_ length data (match null_bitmap with | None -> null | Some v -> v) n_nulls in
    if Ctypes.is_null res
    then failwith "returned null";
    Gc.finalise C.object_unref res;
    res

  let get_value t__ i =
    let res = C.UInt32Array.get_value t__ i in
    res

  let sum t__ =
    let gerr__ = CArray.make (ptr C.GError.t) 1 in
    let res = C.UInt32Array.sum t__ (CArray.start gerr__) in
    let gerr__ = CArray.get gerr__ 0 in
    if not (Ctypes.is_null gerr__)
    then begin
      let msg = getf (!@ gerr__) C.GError.message in
      if Ctypes.is_null msg
      then failwith "failed with null error message";
      let msg = C.strdup msg in
      C.GError.free gerr__;
      failwith msg
    end;
    res

end

module UInt32ArrayBuilder = struct
  type t = [ `u_int32_array_builder | `array_builder ] gobject
  let of_gobject g =
    if C.UInt32ArrayBuilder.get_type () = C.gobject_type g
    then Some g else None

  let new_ () =
    let res = C.UInt32ArrayBuilder.new_ () in
    if Ctypes.is_null res
    then failwith "returned null";
    Gc.finalise C.object_unref res;
    res

  let append_null t__ =
    let gerr__ = CArray.make (ptr C.GError.t) 1 in
    let res = C.UInt32ArrayBuilder.append_null t__ (CArray.start gerr__) in
    let gerr__ = CArray.get gerr__ 0 in
    if not (Ctypes.is_null gerr__)
    then begin
      let msg = getf (!@ gerr__) C.GError.message in
      if Ctypes.is_null msg
      then failwith "failed with null error message";
      let msg = C.strdup msg in
      C.GError.free gerr__;
      failwith msg
    end;
    res

  let append_nulls t__ n =
    let gerr__ = CArray.make (ptr C.GError.t) 1 in
    let res = C.UInt32ArrayBuilder.append_nulls t__ n (CArray.start gerr__) in
    let gerr__ = CArray.get gerr__ 0 in
    if not (Ctypes.is_null gerr__)
    then begin
      let msg = getf (!@ gerr__) C.GError.message in
      if Ctypes.is_null msg
      then failwith "failed with null error message";
      let msg = C.strdup msg in
      C.GError.free gerr__;
      failwith msg
    end;
    res

  let append_value t__ value =
    let gerr__ = CArray.make (ptr C.GError.t) 1 in
    let res = C.UInt32ArrayBuilder.append_value t__ value (CArray.start gerr__) in
    let gerr__ = CArray.get gerr__ 0 in
    if not (Ctypes.is_null gerr__)
    then begin
      let msg = getf (!@ gerr__) C.GError.message in
      if Ctypes.is_null msg
      then failwith "failed with null error message";
      let msg = C.strdup msg in
      C.GError.free gerr__;
      failwith msg
    end;
    res

end

module UInt32DataType = struct
  type t = [ `u_int32_data_type | `integer_data_type | `numeric_data_type | `fixed_width_data_type | `data_type ] gobject
  let of_gobject g =
    if C.UInt32DataType.get_type () = C.gobject_type g
    then Some g else None

  let new_ () =
    let res = C.UInt32DataType.new_ () in
    if Ctypes.is_null res
    then failwith "returned null";
    Gc.finalise C.object_unref res;
    res

end

module UInt64Array = struct
  type t = [ `u_int64_array | `numeric_array | `primitive_array | `array_ ] gobject
  let of_gobject g =
    if C.UInt64Array.get_type () = C.gobject_type g
    then Some g else None

  let new_ ?null_bitmap length data n_nulls =
    let res = C.UInt64Array.new_ length data (match null_bitmap with | None -> null | Some v -> v) n_nulls in
    if Ctypes.is_null res
    then failwith "returned null";
    Gc.finalise C.object_unref res;
    res

  let get_value t__ i =
    let res = C.UInt64Array.get_value t__ i in
    res

  let sum t__ =
    let gerr__ = CArray.make (ptr C.GError.t) 1 in
    let res = C.UInt64Array.sum t__ (CArray.start gerr__) in
    let gerr__ = CArray.get gerr__ 0 in
    if not (Ctypes.is_null gerr__)
    then begin
      let msg = getf (!@ gerr__) C.GError.message in
      if Ctypes.is_null msg
      then failwith "failed with null error message";
      let msg = C.strdup msg in
      C.GError.free gerr__;
      failwith msg
    end;
    res

end

module UInt64ArrayBuilder = struct
  type t = [ `u_int64_array_builder | `array_builder ] gobject
  let of_gobject g =
    if C.UInt64ArrayBuilder.get_type () = C.gobject_type g
    then Some g else None

  let new_ () =
    let res = C.UInt64ArrayBuilder.new_ () in
    if Ctypes.is_null res
    then failwith "returned null";
    Gc.finalise C.object_unref res;
    res

  let append_null t__ =
    let gerr__ = CArray.make (ptr C.GError.t) 1 in
    let res = C.UInt64ArrayBuilder.append_null t__ (CArray.start gerr__) in
    let gerr__ = CArray.get gerr__ 0 in
    if not (Ctypes.is_null gerr__)
    then begin
      let msg = getf (!@ gerr__) C.GError.message in
      if Ctypes.is_null msg
      then failwith "failed with null error message";
      let msg = C.strdup msg in
      C.GError.free gerr__;
      failwith msg
    end;
    res

  let append_nulls t__ n =
    let gerr__ = CArray.make (ptr C.GError.t) 1 in
    let res = C.UInt64ArrayBuilder.append_nulls t__ n (CArray.start gerr__) in
    let gerr__ = CArray.get gerr__ 0 in
    if not (Ctypes.is_null gerr__)
    then begin
      let msg = getf (!@ gerr__) C.GError.message in
      if Ctypes.is_null msg
      then failwith "failed with null error message";
      let msg = C.strdup msg in
      C.GError.free gerr__;
      failwith msg
    end;
    res

  let append_value t__ value =
    let gerr__ = CArray.make (ptr C.GError.t) 1 in
    let res = C.UInt64ArrayBuilder.append_value t__ value (CArray.start gerr__) in
    let gerr__ = CArray.get gerr__ 0 in
    if not (Ctypes.is_null gerr__)
    then begin
      let msg = getf (!@ gerr__) C.GError.message in
      if Ctypes.is_null msg
      then failwith "failed with null error message";
      let msg = C.strdup msg in
      C.GError.free gerr__;
      failwith msg
    end;
    res

end

module UInt64DataType = struct
  type t = [ `u_int64_data_type | `integer_data_type | `numeric_data_type | `fixed_width_data_type | `data_type ] gobject
  let of_gobject g =
    if C.UInt64DataType.get_type () = C.gobject_type g
    then Some g else None

  let new_ () =
    let res = C.UInt64DataType.new_ () in
    if Ctypes.is_null res
    then failwith "returned null";
    Gc.finalise C.object_unref res;
    res

end

module UInt8Array = struct
  type t = [ `u_int8_array | `numeric_array | `primitive_array | `array_ ] gobject
  let of_gobject g =
    if C.UInt8Array.get_type () = C.gobject_type g
    then Some g else None

  let new_ ?null_bitmap length data n_nulls =
    let res = C.UInt8Array.new_ length data (match null_bitmap with | None -> null | Some v -> v) n_nulls in
    if Ctypes.is_null res
    then failwith "returned null";
    Gc.finalise C.object_unref res;
    res

  let get_value t__ i =
    let res = C.UInt8Array.get_value t__ i in
    res

  let sum t__ =
    let gerr__ = CArray.make (ptr C.GError.t) 1 in
    let res = C.UInt8Array.sum t__ (CArray.start gerr__) in
    let gerr__ = CArray.get gerr__ 0 in
    if not (Ctypes.is_null gerr__)
    then begin
      let msg = getf (!@ gerr__) C.GError.message in
      if Ctypes.is_null msg
      then failwith "failed with null error message";
      let msg = C.strdup msg in
      C.GError.free gerr__;
      failwith msg
    end;
    res

end

module UInt8ArrayBuilder = struct
  type t = [ `u_int8_array_builder | `array_builder ] gobject
  let of_gobject g =
    if C.UInt8ArrayBuilder.get_type () = C.gobject_type g
    then Some g else None

  let new_ () =
    let res = C.UInt8ArrayBuilder.new_ () in
    if Ctypes.is_null res
    then failwith "returned null";
    Gc.finalise C.object_unref res;
    res

  let append_null t__ =
    let gerr__ = CArray.make (ptr C.GError.t) 1 in
    let res = C.UInt8ArrayBuilder.append_null t__ (CArray.start gerr__) in
    let gerr__ = CArray.get gerr__ 0 in
    if not (Ctypes.is_null gerr__)
    then begin
      let msg = getf (!@ gerr__) C.GError.message in
      if Ctypes.is_null msg
      then failwith "failed with null error message";
      let msg = C.strdup msg in
      C.GError.free gerr__;
      failwith msg
    end;
    res

  let append_nulls t__ n =
    let gerr__ = CArray.make (ptr C.GError.t) 1 in
    let res = C.UInt8ArrayBuilder.append_nulls t__ n (CArray.start gerr__) in
    let gerr__ = CArray.get gerr__ 0 in
    if not (Ctypes.is_null gerr__)
    then begin
      let msg = getf (!@ gerr__) C.GError.message in
      if Ctypes.is_null msg
      then failwith "failed with null error message";
      let msg = C.strdup msg in
      C.GError.free gerr__;
      failwith msg
    end;
    res

  let append_value t__ value =
    let gerr__ = CArray.make (ptr C.GError.t) 1 in
    let res = C.UInt8ArrayBuilder.append_value t__ value (CArray.start gerr__) in
    let gerr__ = CArray.get gerr__ 0 in
    if not (Ctypes.is_null gerr__)
    then begin
      let msg = getf (!@ gerr__) C.GError.message in
      if Ctypes.is_null msg
      then failwith "failed with null error message";
      let msg = C.strdup msg in
      C.GError.free gerr__;
      failwith msg
    end;
    res

end

module UInt8DataType = struct
  type t = [ `u_int8_data_type | `integer_data_type | `numeric_data_type | `fixed_width_data_type | `data_type ] gobject
  let of_gobject g =
    if C.UInt8DataType.get_type () = C.gobject_type g
    then Some g else None

  let new_ () =
    let res = C.UInt8DataType.new_ () in
    if Ctypes.is_null res
    then failwith "returned null";
    Gc.finalise C.object_unref res;
    res

end

module UIntArrayBuilder = struct
  type t = [ `u_int_array_builder | `array_builder ] gobject
  let of_gobject g =
    if C.UIntArrayBuilder.get_type () = C.gobject_type g
    then Some g else None

  let new_ () =
    let res = C.UIntArrayBuilder.new_ () in
    if Ctypes.is_null res
    then failwith "returned null";
    Gc.finalise C.object_unref res;
    res

  let append_null t__ =
    let gerr__ = CArray.make (ptr C.GError.t) 1 in
    let res = C.UIntArrayBuilder.append_null t__ (CArray.start gerr__) in
    let gerr__ = CArray.get gerr__ 0 in
    if not (Ctypes.is_null gerr__)
    then begin
      let msg = getf (!@ gerr__) C.GError.message in
      if Ctypes.is_null msg
      then failwith "failed with null error message";
      let msg = C.strdup msg in
      C.GError.free gerr__;
      failwith msg
    end;
    res

  let append_nulls t__ n =
    let gerr__ = CArray.make (ptr C.GError.t) 1 in
    let res = C.UIntArrayBuilder.append_nulls t__ n (CArray.start gerr__) in
    let gerr__ = CArray.get gerr__ 0 in
    if not (Ctypes.is_null gerr__)
    then begin
      let msg = getf (!@ gerr__) C.GError.message in
      if Ctypes.is_null msg
      then failwith "failed with null error message";
      let msg = C.strdup msg in
      C.GError.free gerr__;
      failwith msg
    end;
    res

  let append_value t__ value =
    let gerr__ = CArray.make (ptr C.GError.t) 1 in
    let res = C.UIntArrayBuilder.append_value t__ value (CArray.start gerr__) in
    let gerr__ = CArray.get gerr__ 0 in
    if not (Ctypes.is_null gerr__)
    then begin
      let msg = getf (!@ gerr__) C.GError.message in
      if Ctypes.is_null msg
      then failwith "failed with null error message";
      let msg = C.strdup msg in
      C.GError.free gerr__;
      failwith msg
    end;
    res

end

module UnionArray = struct
  type t = [ `union_array | `array_ ] gobject
  let of_gobject g =
    if C.UnionArray.get_type () = C.gobject_type g
    then Some g else None

  let get_field t__ i =
    let res = C.UnionArray.get_field t__ i in
    if Ctypes.is_null res
    then failwith "returned null";
    Gc.finalise C.object_unref res;
    res

end

module UnionDataType = struct
  type t = [ `union_data_type | `data_type ] gobject
  let of_gobject g =
    if C.UnionDataType.get_type () = C.gobject_type g
    then Some g else None

  let get_field t__ i =
    let res = C.UnionDataType.get_field t__ i in
    if Ctypes.is_null res
    then failwith "returned null";
    Gc.finalise C.object_unref res;
    res

  let get_n_fields t__ =
    let res = C.UnionDataType.get_n_fields t__ in
    res

end

